[
  
  {
    "title": "Beerlot 프로젝트 첫 번째 회고",
    "url": "/posts/beerlot-retrospective-1/",
    "categories": "Toy-Project",
    "tags": "Retrospective, Beerlot",
    "date": "2022-10-06 00:00:00 +0200",
    





    
    "snippet": "  Beerlot v0.5.0-alpha release를 기념하며 작성하는 회고개요올해 8월부터 새로운 토이 프로젝트를 시작했다. 서비스명은 Beerlot(비어랏)으로, 이름에서 알 수 있듯이 맥주를 테마로 하는 일종의 커뮤니티 서비스이다. ‘맥주가 많다(Beer가 lot하다)’와 ‘맥주(잔)을 비어랏!’의 두 가지 의미를 가지고 있다. 나의 취향을 ...",
    "content": "  Beerlot v0.5.0-alpha release를 기념하며 작성하는 회고개요올해 8월부터 새로운 토이 프로젝트를 시작했다. 서비스명은 Beerlot(비어랏)으로, 이름에서 알 수 있듯이 맥주를 테마로 하는 일종의 커뮤니티 서비스이다. ‘맥주가 많다(Beer가 lot하다)’와 ‘맥주(잔)을 비어랏!’의 두 가지 의미를 가지고 있다. 나의 취향을 아주 제대로 저격한 프로젝트라고 말할 수 있겠다.🤩🔽 내가 2년 동안 독일에서 마셔본 맥주 병뚜껑 모음프론트엔드 개발자님이 제안해주신 Agile 회고 방식 중 하나인 KPT 회고를 따라 작성해보려고 한다.K(Keep)K1: 팀원들의 동일한 목표팀 단위의 토이 프로젝트에서 가장 중요한 것은 각자 프로젝트에 대해 가지고 있는 목표&amp;기대라고 생각한다. 팀원은 총 3명으로 각각 프론트엔드 개발자 1명, 백엔드 개발자(나) 1명, 기획 및 디자이너 1명이다. Beerlot 프로젝트를 시작하면서 내 개인적인 목표는 크게 두 가지였다.  회사에서 사용 중인 Google Cloud Platform 연습하기  실사용 유저가 있는 서비스 운영하기특히 두 번째 목표에 덧붙여, 유저의 피드백을 받아 다음 버전 업데이트에 반영하면서 확장해나가는 형태의 서비스를 구축하고 싶었다. 프로젝트가 중/장기적일 수 밖에 없다. 만약 팀원 중 하나가 포트폴리오 목적으로 2달 안에 뚝딱 만들어야하는 프로젝트를 기대했다면 모두가 만족하는 결과물을 얻기 힘들 것이다.K2: 체계적인 프로젝트 관리프로젝트 관리는 노션을, 소통은 슬랙을 이용해서 하고 있다. 노션이라는 툴이 자유도가 높은 만큼 서로가 이해하고 편하게 쓸 수 있는 보드와 템플릿을 만들기 위해 초반에 시간을 좀 들였다. 결과는 대만족!🔽 Beerlot의 칸반 보드🔽 Beerlot의 아이디에이션 보드v1.0.0 릴리즈에 해당되지 않는 아이디어들이 많다. 나중에 하나씩 다 구현해나갈 수 있으면 좋겠다.🙃🔽 Beerlot의 마일스톤K3: v0.5.0-alpha 버전 배포v1.0.0 배포를 하기 전에 internal용으로 중간 버전인 v0.5.0-alpha를 배포하기로 했다. 이건 예전에 했던 토이 프로젝트에서 경험한건데, 중간 버전을 배포하면 단기적인 목표에 좀 더 집중할 수 있고, v1.0.0을 배포하기 전에 한 번 더 점검할 기회가 생긴다. 수능 치기 전에 여러 번 모의고사를 치는 것과 같은 느낌이랄까… 정말 최소한의 기능만 계획해서 v0.5.0-alpha의 마감 기한을 정했다. 도달하지 못한 목표도 있었고 버그 투성이지만 어찌됐건 2달 만에 Beerlot앱이 탄생하게 되었다.K4: 적당히 쉬는 것도 기술v0.5.0-alpha 배포를 준비하면서 꽤나 달렸다. 마지막 일주일은 마침(?) 비가 쏟아져서 재택 끝나고 집에서 콕 박혀 작업만 했다. 배포하는 날 회의에서 프론트엔드 개발자님이 1주일의 휴가를 제안했다. ‘지쳤으면 -&gt; 쉰다’ 당연한건데 쉴 생각을 못했다. KPT 회고를 쓰는 것도 그 분의 제안인데 그 동안의 시간을 정리하면서 앞으로의 더 보람찬 시간을 기대해본다.P(Problem)P1: 코드 품질테스트 코드를 작성하다가 마감 기한에 임박하면서 테스트 코드 작성을 리펙토링 바로 앞으로 미뤄버렸다. 코드 품질을 보장하는 유일하면서 최소한의 장치였는데 API를 넘겨주는 게 우선이라는 생각에 그랬던 것 같다. 반성한다 나 자신…P2: 일정 관리프론트엔드 개발자와 디자이너는 화면 단위로 일정을 맞추어 나갔다. 이 화면 단위의 일정이 백엔드인 내 입장에서는 좀 애매하게 느껴졌다. 작업의 복잡도가 화면의 복잡도와 상관이 없어서일까… 예를 들어, 메인 화면을 제일 먼저 만든다고 가정해본다. 메인 화면에는 사용자가 남긴 리뷰의 별점을 기준으로 인기 맥주를 보여준다. 아무것도 없는 제로 코드에서 이 API 하나를 만들기 위해서는 생각보다 고려해야할 것이 많다. 연관된 엔티티가 많기 때문이다. 인기 맥주 관점에서 보면 맥주, 사용자, 리뷰가 연관되어 있고 맥주 정보 카드 관점에서 보면 맥주, 카테고리, 태그 등이 연관되어 있다. 즉, 인기 맥주 10개를 뽑기 위해서 맥주 엔티티뿐 만 아니라 사용자, 리뷰, 카테고리, 태그 등을 고려해야한다.T(Try)T1: Code Coverage 측정 &amp; Quality Gate 제한Code coverage 측정하는 JaCoCo, Quality gate를 설정하는 SonarQube와 같은 툴을 이용해서 GitHub에서 merge하기 전 Quality gate 통과 못했을 때 merge를 제한하는 방식으로 약간은 반강제적이지만 코드 품질을 상승시켜 유지할 수 있는 방법을 도입해야겠다.T2: Swagger 적극 활용 &amp; 기능 위주의 일정 조율이 부분은 팀원들이랑 한 번 얘기해봐야겠지만 내가 생각하는 방안은 Swagger를 적극 활용해서 내가 당장 만들기 어려운 API는 API 명세를 우선 작성해 Mock 응답을 참고해달라고 프론트엔드 개발자님에게 양해를 구한다.두 번째 방안은 이상적인 API 개발 순서를 정해 프론트엔드 개발자님의 작업 순서와 비교해 조율하는 것이다.추가로 KPT에 해당되지는 않지만 그동안 어려웠던 점을 정리해보려고 한다.어려웠던 점결정도 혼자, 책임도 혼자기획 및 디자인, 백엔드, 프론트엔드 각 분야 당 1명이 맡고 있기 때문에 백엔드 내 결정해야할 것들은 나 혼자의 몫이 되었다. 초반에 프로젝트 셋업하는 과정에 시간을 많이 썼다. ‘JPA를 쓸까? MyBatis를 써볼까?’ ‘좀 더 깔끔한 API 문서 없나?’ 백엔드 기술 스택을 결정하는 것조차 쉽지는 않았다. 심지어 OpenAPI Generator는 포함시켜 개발하다가 우리 프로젝트에는 효율적이지 않은 것 같아서 뺐다가 결국엔 욕심이 나서 해결방법을 모색해 다시 넣었다. 꽤나 울고 싶었다…🥲CI/CD = Heaven beyond HellBeerlot의 백엔드 서버는 Github Actions를 이용한 CI/CD를 통해 GCP Cloud Run으로 배포된다. 테스트 -&gt; 빌드 -&gt; 도커 이미지 생성 -&gt; Artifact Registry에 도커 이미지 배포 -&gt; Cloud Run의 과정을 거치는데 CD 워크플로우만 64번 시도 끝에 성공했다. 빨간색을 좋아하는 개발자도 있을까…?CI/CD 파이프라인을 구축해두니 하루에 여러 번 배포를 해도 작업량에 부담이 없기는 하다.마치며열정적인 팀원들과 앞으로가 기대되는 프로젝트이다. v1.0.0 release는 나에게 주는 2023년 새해 선물이 될 예정이다!🎁"
  },
  
  {
    "title": "SOLID 원칙, 직접 예제 만들어 이해하기",
    "url": "/posts/solid-principles-with-my-examples/",
    "categories": "Design-Pattern",
    "tags": "OOD",
    "date": "2022-07-29 00:00:00 +0200",
    





    
    "snippet": "  온라인 숍이라는 익숙한 도메인으로 SOLID 원칙의 예제를 만들어 보았다. 각각의 원칙을 전제 조건, 원칙을 위배하는 설계, 원칙을 만족하는 설계로 나누어 설명해보았다.답답해서 직접 만든 예제🤓 혹시 틀린 부분, 개선할 부분이 있다면 댓글 남겨 주시면 감사하겠습니다. (‘-‘)(,_,)개요Clean Code의 저자로 잘 알려진 Robert C. M...",
    "content": "  온라인 숍이라는 익숙한 도메인으로 SOLID 원칙의 예제를 만들어 보았다. 각각의 원칙을 전제 조건, 원칙을 위배하는 설계, 원칙을 만족하는 설계로 나누어 설명해보았다.답답해서 직접 만든 예제🤓 혹시 틀린 부분, 개선할 부분이 있다면 댓글 남겨 주시면 감사하겠습니다. (‘-‘)(,_,)개요Clean Code의 저자로 잘 알려진 Robert C. Martin이 2000년도 그의 논문 “Design Principles and Design Patterns”에 소개한 개념이다. 후에 Michael Feathers가 각 원칙의 첫 글자를 따서 SOLID라는 명칭을 만들었는데, Robert C. Martin도 이름이 있으니 대단한 원칙처럼 느껴진다며 SOLID라고 부르기 시작했다.SOLID 원칙은 OOD(Object Oriented Design)를 위한 개념이다. 이 원칙을 따르면 가독성과 확장성이 좋고 유연하며 유지보수가 쉬운 소프트웨어를 설계할 수 있다. SOLID를 구성하는 각각의 원칙은 다음과 같다.  S: Single Responsibility Principle(SRP)  O: Open Closed Principle(OCP)  L: Liskov Substitution Principle(LSP)  I: Interface Segragation Principle(ISP)  D: Dependency Inversion Principle(DIP)참고로 “Design Principles and Design Patterns”에서는 무슨 영문인지 단일 책임 원칙에 대한 내용을 찾을 수 없었다. 하지만 Robert C. Martin의 한 강연을 보면 그가 단일 책임 원칙에 대해 설명하는 것을 볼 수 있다.Single Responsibility Principle(SRP, 단일 책임 원칙)A class should have one and only one reason to change. 클래스는 변경되어야 할 단 하나의 이유만을 가져야 한다.전제 상황|------|        |-------------|| Shop |------&gt; |    Order    ||------|        |-------------|                | + ship()    |                | + cancel()  |                | + retour()  |                |-------------|  Order 클래스는 배송(ship()), 주문 취소(cancel()), 반품(retour())의 메서드를 가지고 있다.원칙 위배하나의 클래스가 세 개의 책임을 가지고 있으므로 단일 책임 원칙을 위배한다.원칙 만족                                           |------------------|                                           | CancelDepartment |                                       |---|------------------|                                       |   | + cancel()       ||------|        |-------------| &lt;------|   |------------------|| Shop |------&gt; |    Order    ||------|        |-------------| &lt;------|   |------------------|                | + ship()    |        |---| RetourDepartment |                |-------------|            |------------------|                                           | + retour()       |                                           |------------------|책임을 분산시켜 표현한다. (⚠️ 단일 책임 원칙만 적용했기 때문에 최선의 설계가 아니다.) 이제 반품 정책에 바뀌면 RetourDepartment 클래스에만 변경이 일어난다.Open Closed Principle(OCP, 개방 폐쇄 원칙)A module should be open for extension but closed for modification.모듈은 확장에는 열려 있고, 변경에는 닫혀있어야 한다.OOD의 모든 원칙들을 통틀어 가장 중요한 원칙이다. 모듈의 소스코드를 변경하지 않으면서 모듈이 하는 일을 변경할 수 있어야 한다. 모순 같아 보이지만 추상화(abstraction)를 이용하면 실현 가능하다.전제 상황|------|        |----------------------|   |-----------------|| Shop |------&gt; |        Order         |   | &lt;&lt;enumeration&gt;&gt; ||------|        |----------------------|   |   ShippingType  |                | - type: ShippingType |   |-----------------|                |----------------------|   | + DOMESTIC      |                | + ship()             |   | + INTERNATIONAL |                | + cancel()           |   |-----------------|                | + retour()           |                |----------------------|                    ^                ^                         |                |                  |----------|     |---------------|            | DOMESTIC |     | INTERNATIONAL |            |  ORDER   |     |     ORDER     |            |----------|     |---------------|                public class Order {  private ShippingType type;  ...  public void ship() {    if (type == ShippingType.DOMESTIC) {      // Domestic shipping policy    } else if (type == ShippingType.INTERNATIONAL) {      // International shipping policy    }  }  ...}  Order 클래스는 배송 타입(ShippingType)을 변수로 가지고 있다.  현재 배송 타입에는 국내(DOMESTIC)와 국제(INTERNATIONAL)가 있다.  같은 대륙 내 배송에 대해 별도의 배송 정책을 적용하기 위해 대륙(CONTINENTAL)을 추가하려고 한다.  배송 타입에 따라 적용되는 배송 정책이 다르기 때문에 배송 처리 메서드(ship())에서 if문으로 구분지어 표현하였다.원칙 위배|------|        |----------------------|   |-----------------|| Shop |------&gt; |         Order        |   | &lt;&lt;enumeration&gt;&gt; ||------|        |----------------------|   |   ShippingType  |                | - type: ShippingType |   |-----------------|                |----------------------|   | + DOMESTIC      |                | + ship()             |   | + INTERNATIONAL |                | + cancel()           |   | + CONTINENTAL   |                | + retour()           |   |-----------------|                |----------------------|                     ^      ^      ^                          |---------|      |      |-------|                    |                |              |               |----------|  |---------------| |-------------|            | DOMESTIC |  | INTERNATIONAL | | CONTINENTAL |      |  ORDER   |  |     ORDER     | |    ORDER    |      |----------|  |---------------| |-------------|public class Order {  private ShippingType type;  ...  public void ship() {    if (type == ShippingType.DOMESTIC) {      // Domestic shipping policy    } else if (type == ShippingType.INTERNATIONAL) {      // International shipping policy    } else if (type == ShippingType.CONTINENTAL) {      // Continental shipping policy    }  }  ...}요구 사항을 반영하기 위해 ShippingType에 대륙 필드를 추가하고, 배송 메서드(ship())에 if문을 추가하였다.개방 폐쇄 원칙을 만족하려면 배송 타입이 추가되었을 때, 기존의 소스 코드를 변경하지 않고 확장하는 방식으로 구현이 가능해야한다. 하지만 위의 설계에서는 배송 타입이 추가될 때마다 ship() 메서드에 변경이 발생하므로 개방 폐쇄 원칙을 위배한다.원칙 만족                |---------------| |------|        | &lt;&lt;interface&gt;&gt; |   | Shop |------&gt; |     Order     |  |------|        |---------------|                  | + ship()      |                   | + cancel()    |                   | + retour()    |                   |---------------|                   ^    ^    ^                |----------|    |    |-----------|         |               |                |  |----------|  |---------------| |-------------|       | DOMESTIC |  | INTERNATIONAL | | CONTINENTAL |  |  ORDER   |  |     ORDER     | |    ORDER    |  |----------|  |---------------| |-------------|public interface Order {  void ship();  void cancel();  void retour();}public class DomesticOrder implements Order {    ...    @Override    public void processOrder() {        // Domestic shipping policy    }}public class InternationalOrder implements Order {    ...    @Override    public void processOrder() {        // International shipping policy    }}public class ContinentalOrder implements Order {    ...    @Override    public void processOrder() {        // Continental shipping policy    }}Order 인터페이스를 만들고 배송 타입에 따른 각각의 클래스를 만들어 인터페이스를 구현(implements)하였다. 각 클래스에서 ship() 메서드를 오버라이딩 해서 배송 정책을 각각 적용하였다. 이제 새로운 배송 타입이 추가되더라도 기존의 코드를 변경하지 않고 새로 클래스를 만들고 인터페이스를 구현하는 방식으로 확장이 가능하게 되었다.Liskov Substitution Principle(LSP, 리스코프 치환 원칙)Subclasses should be substitutable for their base classes. 하위 클래스는 상위 클래스를 대체할 수 있어야 한다.|------|        |-------|| Shop |------&gt; | Order ||------|        |-------|                    ^                    |              |--------------|                  | OrderDerived |              |--------------|Shop이 Order 클래스를 사용하고 있고, OrderDerived는 Order로부터 파생된 것을 표현한 다이어그램이다. 리스코프 치환 원칙을 만족하려면 Order가 OrderDerived로 대체되더라도 Shop은 정상 기능해야한다.상속 관계에서는 자식 클래스가 부모 클래스의 모든 것을 상속 받기 때문에 당연하다고 생각할 수도 있지만 고려해야할 문제가 있다. 바로 Circle/Ellipse Dilemma이다.Circle/Ellipse Dilemma(원과 타원 딜레마)  is a 관계에 놓인 두 객체를 모델링할 때 발생하는 딜레마로, Square/Rectangle Dilemma(사각형과 직사각형 딜레마)라고도 부른다.모든 원은 타원이다. 원은 두 초점이 같은 타원이기 때문에 원은 타원에 속한다고 말할 수 있다. 이를 상속 관계로 나타내면 아래의 다이어그램과 같다.|---------|| Ellipse ||---------|     ^     ||--------|| Circle ||--------|     타원을 아래와 같이 정의했다고 가정해본다.|-------------------------------||  Ellipse                      ||-------------------------------|| - fociA: Point                || - fociB: Point                || - majorAxis: Double           ||-------------------------------|| + getFociA(): Point           || + getFociB(): Point           || + getMajorAxis(): Double      || + setFoci(a: Point, b: Point) || + setMajorAxis(axis: Double)  ||-------------------------------|원은 타원을 상속하기 때문에 초점이 한 개만 필요함에도 불구하고 초점 변수 두 개를 가지게 된다. 오버헤드를 감수한다면 원의 setFoci(Point a, Point b) 메서드를 오버라이딩해서 두 개의 초점이 같은 값을 가지도록 수정하면 타원을 상속하면서 원으로써 기능하도록 구현할 수는 있다.void Ellipse::SetFoci(const Point&amp; a, const Point&amp; b){  itsFocusA = a;  itsFocusB = b;}// Overridevoid Circle::SetFoci(const Point&amp; a, const Point&amp; b){  itsFocusA = a;  itsFocusB = a;}Ellipse를 이용한 다음 함수를 통해 위의 원과 타원의 설계가 리스코프 치환 원칙을 만족하는지 생각해본다.void f(Ellipse&amp; e){  Point a(-1,0);  Point b(1,0);  e.setFoci(a,b);  e.setMajorAxis(3);  assert(e.getFociA() == a);  assert(e.getFociB() == b);  assert(e.getMajorAxis() == 3);}리스코프 치환 원칙을 만족하려면 Ellipse를 Circle로 바꿨을 때 함수가 정상적으로 작동해야한다. 하지만 Circle로 바꾸면 두 번째 assert문인 assert(e.getFociB() == b)에서 에러가 난다.즉, 상속 관계에 있다고 해서 항상 리스코프 치환 원칙이 만족되는 것은 아니다. 리스코프 치환 원칙을 만족하기 위해서 자식 클래스는 부모 클래스의 명세를 반드시 지켜야한다. 위의 예시에서는 Circle이 Ellipse의 “초점은 두 개이다.”라는 명세를 지키지 않았다. 명세에서 다음 두 가지 조건이 충족되면 상속 관계에서 리스코프 치환 원칙이 만족된다고 할 수 있다.  자식 클래스의 선행 조건(precondition)이 부모 클래스의 메서드보다 강하지 않다.  자식 클래스의 후행 조건(postcondition)이 부모 클래스의 메서드보다 약하지 않다.*선행 조건(precondition): 메서드가 호출되기 전에 참이어야 하는 것*후행 조건(postcondition): 메서드가 완료된 후에 참이어야 하는 것위의 함수를 다음과 같이 수정하면 리스코프 치환 원칙을 만족하게 만들 수는 있다. 하지만 소스 코드의 변경은 또 다시 개방 폐쇄 원칙을 위반하게 한다. 즉, 리스코프 치환 원칙의 위반은 곧 개방 폐쇄 원칙의 위반으로 이어진다.void f(Ellipse&amp; e){  if (typeid(e) == typeid(Ellipse)) {    Point a(-1,0);    Point b(1,0);    e.setFoci(a,b);    e.setMajorAxis(3);    assert(e.getFociA() == a);    assert(e.getFociB() == b);    assert(e.getMajorAxis() == 3);  }  else {    throw NotAnEllipse(e);  }}Interface Segragation Principle(ISP, 인터페이스 분리 원칙)Many client specific interfaces are better than one general purpose interface. 특정 클라이언트만을 위한 인터페이스 여러 개가 하나의 범용 인터페이스보다 낫다.전제 상황|--------|| Shop A |------|        |---------------||--------|      |------&gt; | &lt;&lt;interface&gt;&gt; |                            |     Order     |                |        |---------------||--------|      |------&gt; | + ship()      || Shop B |------|        | + cancel()    |    |--------|               | + detour()    |                         |---------------|  Shop A와 Shop B 모두 Order 인터페이스를 구현하여 사용하고 있다.  Shop A가 예약 배송(schedule()) 기능 추가를 요구했다.  Shop B는 예약 배송을 지원하지 않는다.원칙 위배|--------|| Shop A |------|        |---------------||--------|      |------&gt; | &lt;&lt;interface&gt;&gt; |                         |     Order     |                |        |---------------||--------|      |------&gt; | + ship()      || Shop B |------|        | + cancel()    |    |--------|               | + detour()    |                         | + schedule()  |                         |---------------|Order 인터페이스에 schedule() 메서드를 추가해 요구 사항을 반영했다. 인터페이스 분리 원칙을 만족하려면 인터페이스는 클라이언트로 하여금 불필요한 메서드를 구현하도록 강요하지 않아야한다. 하지만 위의 예제에서 Shop B는 예약 배송 기능을 지원하지 않음에도 불구하고 해당 메서드를 구현해야한다.원칙 만족                |----------------|                | &lt;&lt;interface&gt;&gt;  |  |--------|      |   Schedulable  || Shop A |------|----------------|------|     |---------------||--------|      | + schedule()   |      |     | &lt;&lt;interface&gt;&gt; |                |----------------|      |---&gt; |     Order     |                                               |---------------|                                        |---&gt; | + ship()      ||--------|                              |     | + cancel()    || Shop B |------------------------------|     | + detour()    ||--------|                                    |---------------|                                         모든 클라이언트의 요구 사항을 하나의 인터페이스로 만드는 것보다 특정 클라이언트만을 위한 인터페이스를 만들게 되더라도 인터페이스를 분리하여야 한다.Dependency Inversion Principle(DIP, 의존관계 역전 원칙)Depend upon Abstractions. Do not depend upon concretions. 구체화가 아닌 추상화에 의존해야한다.개방 폐쇄 원칙이 OO 아키텍처의 목표를 나타낸다면, 의존관계 역전 원칙은 주요 원리를 나타낸다. 의존관계 역전 원칙은 구체적인 함수나 클래스에 의존하기보다는 인터페이스나 추상적 함수, 추상적 클래스에 의존해야한다는 것이다.전제 상황        |------|        | Shop |        |------|                |            v     |--------------|     | OrderService |     |--------------|       |          |       v          v|----------|   |------|| Domestic |   | User ||   Order  |   |------||----------|     public class OrderService {  private DomesticOrder Order;  private User user;  OrderService(DomesticOrder order, User user) {    domesticOrder = new DomesticOrder();    user = user;  }}  Shop이 OrderService를, OrderService는 DomesticOrder와 User 클래스에 의존하고 있다.  Shop이 이제 국제 배송을 지원해 InternationOrder를 추가해야한다.원칙 위배             |------|             | Shop |             |------|                     |                 v          |--------------|          | OrderService |          |--------------|           |    |      |      |----|    |      |----------|       v         v                 v|----------|  |---------------|  |------|| Domestic |  | International |  | User ||   Order  |  |     Order     |  |------||----------|  |---------------|public class OrderService {  private DomesticOrder domesticOrder;  private InternationalOrder internationalOrder;  private User user;  OrderService(DomesticOrder domesticOrder, User user) {    domesticOrder = new DomesticOrder();    internationalOrder = null;    user = user;  }  OrderService(InternationalOrder internationalOrder, User user) {    internationalOrder = new InternationalOrder();    domesticOrder = null;    user = user;  }}최상위 모듈 Shop은 어플리케이션 상위 정책들을 다룬다. 이 상위 정책들은 일반적으로 세부 구현 사항에 크게 관심을 갖지 않는다. 그럼에도 불구하고 상위 모듈이 하위 모듈에 의존하는 순차적 설계에서는 최상위 모듈이 세부 구현 사항을 다루는 최하위의 모듈에 직접적으로 의존한다.요구 사항을 반영한 위 설계는 OrderService가 구체적 클래스인 DomesticOrder와 InternationalOrder에 직접적으로 의존하고 있어 의존관계 역전 원칙을 위배한다.원칙 만족              |------|              | Shop |              |------|                      |                  v            |--------------|            | OrderService |            |--------------|               |          |               v          v    |---------------|    |---------------|    | &lt;&lt;interface&gt;&gt; |    | &lt;&lt;interface&gt;&gt; |    |     Order     |    |      User     |    |---------------|    |---------------|      ^          ^                   ^      |          |                   ||----------|  |---------------|   |------|| Domestic |  | International |   | User ||   Order  |  |     Order     |   |------||----------|  |---------------|public interface Order() {...}public class DomesticOrder implements Order {...}public class InternationalOrder implements Order {...}public class OrderService {  private Order order;  private User user;  OrderService(Order order, User user) {    order = new Order();    user = user;  }}Order 인터페이스를 만들고 DomesticOrder와 InternationalOrder 클래스에서 인터페이스를 구현한다. 상위 모듈 뿐만 아니라 하위 구현 클래스도 인터페이스에 의존하는 것을 의존관계의 역전이라고 표현한다. (위 다이어그램에서 화살표 방향 참고)의존관계를 역전해야하는 이유는 간단하다. 구체적인 것에 비해 추상적인 것은 변경이 훨씬 적게 발생하고, 추상적인 것은 변경 없이 설계를 바꾸는 것이 가능하기 때문이다. 이는 곧 개방 폐쇄 원칙으로 이어진다.참고  http://staff.cs.utu.fi/~jounsmed/doos_06/material/DesignPrinciplesAndPatterns.pdf  https://www.baeldung.com/solid-principles  https://www.youtube.com/watch?v=TMuno5RZNeE"
  },
  
  {
    "title": "[GitHub] 여러 개의 GitHub 계정 SSH로 연결하기",
    "url": "/posts/manage-multiple-github-accounts-with-ssh/",
    "categories": "Git/GitHub",
    "tags": "GitHub",
    "date": "2022-07-22 00:00:00 +0200",
    





    
    "snippet": "  how to manage multiple GitHub accounts with SSH[1] SSH 키를 생성각 GitHub 계정에 대해 SSH 키를 생성한다.ssh-keygen -t rsa -b 4096 -C \"email_organization@example.com\"ssh-keygen -t rsa -b 4096 -C \"email_personal@e...",
    "content": "  how to manage multiple GitHub accounts with SSH[1] SSH 키를 생성각 GitHub 계정에 대해 SSH 키를 생성한다.ssh-keygen -t rsa -b 4096 -C \"email_organization@example.com\"ssh-keygen -t rsa -b 4096 -C \"email_personal@example.com\"  -t(type): 키 알고리즘 명시  -b(bits): 키 사이즈 명시  -C(comment): public key 뒤에 붙음.두 개의 SSH 키를 구분짓기 위해 키 이름을 물을 때 고유한 키 이름을 입력한다. 회사용은 org_id_rsa, 개인용은 per_id_rsa로 생성했다고 가정하겠다.&gt; Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]각 계정에 대해 각각 공개키(.pub)와 개인키가 생성된 것을 확인할 수 있다.ls ~/.sshorg-id-rsa      per-id-rsa org-id-rsa.pub  per-id-rsa.pub  [2] SSH config 설정설정 파일이 존재하지 않으면 ~/.ssh에 config 이름으로 새로 파일을 만든다.Host github.com-&lt;개인용 GibHub username&gt;  HostName github.com  User git  AddKeysToAgent yes  IdentityFile ~/.ssh/per-id-rsaHost github.com-&lt;회사용 GitHub username&gt;  HostName github.com  User git  AddKeysToAgent yes  IdentityFile ~/.ssh/org-id-rsa나는 GitHub username을 사용하여 Host를 구분지었는데,  github.com123처럼 의미 없는 값이어도 상관 없다. 두 Host 값이 다르도록 설정해주기만 하면 된다.[3] SSH client에 private key 등록ssh-add -K ~/.ssh/org_id_rsassh-add -K ~/.ssh/per_id_rsa  -K: MAC Keychain에 비밀번호 저장-K 옵션에 대해 에러가 나면 아래와 같이 실행한다. (참고: GitHub Docs - Error: ssh-add: illegal option –K)/usr/bin/ssh-add -K ~/.ssh/org_id_rsa/usr/bin/ssh-add -K ~/.ssh/per_id_rsa// 등록된 키 전부 조회ssh-add -l// 등록된 키 전부 등록 해제ssh-add -D[4] 각 GitHub 계정에 SSH public key 추가4-1. SSH 키 복사pbcopy &lt; ~/.ssh/org_id_rsa.pub공개키를 클립보드에 복사한다.4-2. GitHub에 SSH 키 붙여넣기각각의 GitHub 계정에 로그인한다. Settings &gt; SSH and GPG keys &gt; New SSH key에 복사한 값을 붙여넣는다.[5] 로컬 레포지토리 설정5-1. GitHub 계정 정보 설정레포지토리마다 사용할 GitHub 계정을 설정한다. 여기서 설정한대로 커밋 로그가 남는다.git config --local user.name \"username\"git config --local user.email \"email@example.com\"5-2. remote url 변경remote에서 clone을 해온 경우 remote url의 기본 값은 git@github.com:&lt;username&gt;/&lt;repository_name&gt;.git이다. 여기서 @뒤에 붙는 github.com을 [2]에서 설정한 Host 값과 동일하게 설정해준다.git remote set-url origin git@github.com-&lt;GitHub username&gt;:&lt;username&gt;/&lt;repository_name&gt;.git참고  https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent  https://gist.github.com/jexchan/2351996?permalink_comment_id=4179310#gistcomment-4179310"
  },
  
  {
    "title": "[Spring] Spring 탄생 배경",
    "url": "/posts/spring-history/",
    "categories": "Spring",
    "tags": "🌱Spring",
    "date": "2022-06-24 00:00:00 +0200",
    





    
    "snippet": "  #EJB #POJO #SpringSpring 탄생 배경  🧸 요약: Spring이 탄생하기 이전에는 EJB(Enterprise Java Bean)가 Java 진영의 대표기술이었다. 하지만 EJB는 여러 문제점을 가지고 있었다. 한 개발자가 EJB의 문제점을 지적하며 대체 방안을 소스코드로 작성하여 책을 출간하였다. 이 책을 본 다른 개발자들 몇몇이...",
    "content": "  #EJB #POJO #SpringSpring 탄생 배경  🧸 요약: Spring이 탄생하기 이전에는 EJB(Enterprise Java Bean)가 Java 진영의 대표기술이었다. 하지만 EJB는 여러 문제점을 가지고 있었다. 한 개발자가 EJB의 문제점을 지적하며 대체 방안을 소스코드로 작성하여 책을 출간하였다. 이 책을 본 다른 개발자들 몇몇이 모여 오픈소스화하며 Spring이 탄생하게 되었다.EJB(Enterprise Java Bean)EJB는 Java EE(Enterprise Edition) 구현체 중 하나로 Spring이 탄생하기 이전까지 Java 진영의 대표기술이었다. ‘비지니스 객체를 관리하는 컨테이너를 만들어서 필요할 때마다 컨테이너로부터 객체를 받아서 사용하자‘라는 아이디어에서 시작되었다.다음 기술을 지원하며 기업용 어플리케이션 개발을 단순하게 했다.  트랜잭션 관리  세션 관리  EJB 인스턴스 풀링  지속성  보안  병렬 처리  데이터베이스 커넥션 풀링  인증과 접근 제어그럼에도 불구하고 EJB는 몇 가지 문제점을 가지고 있었는데, 이 문제를 해결하기 위해 대안을 고안하면서 Spring이 탄생하게 되었다.  객체 지향적 개발 불가능: 프레임워크 패키지에 속한 인터페이스를 사용하여 개발을 해야했는데, 이 인터페이스가 tight coupling으로 설계되어있다. 즉, 인터페이스가 서로 의존하고 있기 때문에 유지보수가 어렵고 확장성이 떨어지며 Java라는 객체 지향 언어를 사용하면서 객체 지향의 장점을 이용하지 못했다.  기술 침투 현상: 특정 기술에 한정적인 복잡한 개념들을 이해해야했다. 프로젝트 자체가 기술에 종속되는 기술 침투 현상이 발생했다.  불필요한 구현: 필요하지 않더라도 몇몇의 콜백 함수들을 반드시 구현해야했다.  무거운 웹 서버 사용: EJB 컨테이너는 JBoss, Websphere, Weblogic과 같은 서버의 일부분이었는데, Apache Tomcat과 비교했을 때 굉장히 무거운 서버이다.  단위 테스트가 어려움: EJB 컨테이너 밖에서 어플리케이션을 실행하는 것은 거의 불가능했기 때문에 단위 테스트를 위해 전체 어플리케이션 컨테이너에 배포해야했다.POJO(Plain Old Java Object)POJO는 프레임워크에 종속되지 않은 Java 객체를 의미한다.POJO라는 용어가 탄생한 배경도 재미있다. 세 명의 개발자가 강연을 준비하면서 의도적으로 붙인 이름인데 그 중 한 개발자의 말을 빌리자면,💬 … 그 강연에서 우리는 Entity Bean을 이용하는 것이 아닌 일반 Java 객체로 비지니스 로직을 구현하는 것의 장점에 대해 이야기했어. 우리는 사람들이 왜 그렇게 일반 객체 사용에 반대하는지 궁금했고, 그건 그럴 듯한 이름이 없기 때문이라고 결론지었어. 그래서 우리가 하나 지어줬지. 근데 그게 진짜 잘 먹혔더라고. - Martin Fowler즉, 그냥 ‘Java 객체’라고 불러도 될 것을 사람들로 하여금 특별한 기술로 인식하도록 굳이 이름을 붙인 것이다. 그의 뜻을 따라 나도 POJO를 단순히 직역한 ‘간단한 오래된 방식의 자바 객체’ 보다는 조금의 긍정적 뜻을 담아 ‘전통적 순수 자바 객체‘라고 번역하고 싶다.🤓POJO는 순수한 Java 객체 그 자체로, Java가 본래 가지고 있는 가장 큰 특징인 객체지향적 개발이 가능하도록 했다. 후에 탄생한 Spring은 POJO를 지원한다.Spring 고안Rod Johnson이 EJB의 문제점을 지적하며 EJB 없이도 고품질의 확장 가능한 어플리케이션 개발이 가능하다는 것을 30,000 라인의 소스코드로 선보이며 책을 출간하였다. EJB로 고통받는 다른 개발자들에게 반응이 좋았다고 한다. Juergen Hoeller와 Yann Caroff가 Rod Johnson에게 오픈소스 프로젝트를 제안했다. Yan Caroff가 지은 이름 Spring은 ‘EJB라는 추운 겨울을 지나 따뜻한 봄이 왔다‘라는 의미를 담고 있으며, 2004년 봄의 시작인 3월에 버전 1.0을 공식 배포되었다.번외: JPA(Java Persistence API) 탄생 배경JPA는 Java 진영의 표준 ORM 기술인데, 현재 널리 쓰이고 있는 Hibernate가 JPA 구현체 중 하나이다.Spring 이전에 EJB가 있었다면, Hibernate 이전에는 Entity Bean이 있었다. Entity Bean은 EJB가 지원하는 기능 중 하나였는데 이 또한 지옥이었는지 한 개발자가 앞장 서서 Hibernate라는 대안을 내놓았다. JPA는 Hibernate를 거의 복사+붙여넣기 해서 만들었다고 해도 과언이 아닐만큼 많은 부분 참고하여 만든 표준 인터페이스이다.참고  https://javajee.com/ejb-programming-model-and-pojo-programming-model  https://m.blog.naver.com/sillllver/220593543939  https://martinfowler.com/bliki/POJO.html"
  },
  
  {
    "title": "[Data Structure] Linked List(연결 리스트)",
    "url": "/posts/linked-list/",
    "categories": "Data-Structure",
    "tags": "💼Data-Structure, ☕Java",
    "date": "2022-02-28 00:00:00 +0100",
    





    
    "snippet": "  연결 리스트(Linked List) 1️⃣0️⃣1️⃣ 구현코드 ✅ 테스트코드[1] Linked List 구조  node: 연결 리스트의 각 아이템          data field: 값을 저장      link field: 다음 노드를 가리키는 포인터        head: 연결 리스트의 첫 노드  tail: 연결 리스트의 마지막 노드를 종종 t...",
    "content": "  연결 리스트(Linked List) 1️⃣0️⃣1️⃣ 구현코드 ✅ 테스트코드[1] Linked List 구조  node: 연결 리스트의 각 아이템          data field: 값을 저장      link field: 다음 노드를 가리키는 포인터        head: 연결 리스트의 첫 노드  tail: 연결 리스트의 마지막 노드를 종종 tail라 칭하기도 하는데, 공식적으로 갖춰야하는 포인터는 아닌 것 같아 그림에는 생략하였다.[2] Linked List 종류  단일 연결 리스트(Singly Linked List)          일반적으로 종류를 논하는 것이 아니면 연결 리스트는 단일 연결 리스트를 일컫는다.        이중 연결 리스트(Doubly Linked List)          이전 노드를 가리키는 포인터와 다음 노드를 가리키는 포인터를 가진다.      역방향으로 탐색이 가능하다.      포인터가 2개이기 때문에 단일 연결 리스트에 비해 메모리 공간도 더 요구된다.        원형 연결 리스트(Circular Linked List)          마지막 노드의 포인터가 처음 노드, 즉 head를 가리킨다.      [3] Linked List 특징  배열와 비교하여 연결 리스트의 특징을 알아본다.  배열은 메모리에 연속적으로 공간이 할당된다. 반면에, 연결 리스트는 공간이 연속적일 필요 없이 메모리에 흩어져 분포되어 있다.장점동적 크기를 가진다  배열은 크기가 고정되어 있지만, 연결리스트는 그렇지 않다.삽입 및 삭제가 쉽다  새로운 원소를 중간에 추가하거나 중간에 위치한 원소를 삭제하려면 뒤에 위치하는 원소들의 위치를 한칸씩 옮겨줘야하는 배열에 비해 연결리스트는 비교적 삽입, 삭제가 쉽다.(자세한 방법은 아래에서 설명한다.)단점임의 접근이 불가능하다  배열은 인덱스를 통해 임의 접근(Random Access)이 가능하지만, 연결 리스트는 head 노드에서부터 시작하여 원하는 원소에 접근해야한다.포인터를 위한 메모리가 필요하다  연결 리스트에서는 다음 노드를 가리키는 포인터를 위해 추가적인 메모리 공간이 필요하다.캐싱에 적합하지 않다  배열은 연속적인 공간을 할당하기 때문에 원소들이 인접해 있어 공간적 지역성(Space Locality)을 통해 캐싱을 할 수 있지만, 연결 리스트는 메모리에 분포되어 있기 때문에 캐싱에 적합하지 않다.[4] Linked List 메서드노드 삽입  addFirst(Node node): 연결 리스트의 맨 처음에 새로운 노드 추가  addLast(Node node): 연결 리스트 맨 마지막에 새로운 노드 추가  add(Node node, int position): 특정 위치에 새로운 노드 추가노드 삭제  removeFirst(): 연결 리스트의 맨 처음 노드 삭제  removeLast(): 연결 리스트 맨 마지막 노드 삭제  remove(int position): 특정 위치에 새로운 노드 삭제[5] Linked List 구현  노드 삽입, 삭제에 대해 위에서 언급한 메서드를 구현하고 테스트해보았다!😇🔽 단일 연결 리스트에서의 노드public class Node {    public int value;    public Node next;    public Node(int value) {        this.value = value;        this.next = null;    }}🔽 단일 연결 리스트public class LinkedList {    private Node head;    public void addFirst(Node newNode) { ... }    public void addLast(Node newNode) { ... }    public void add(Node newNode, int position) { ... }    public void removeFirst() { ... }    public void removeLast() { ... }    public void remove(int position) { ... }    public int getSize() { ... }}참고  https://www.geeksforgeeks.org/linked-list-vs-array/?ref=lbp  https://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html"
  },
  
  {
    "title": "[Java Live Study] 4. 제어문(Control Statements)",
    "url": "/posts/3-java-control-statements/",
    "categories": "Java",
    "tags": "☕Java, Java-Live-Study",
    "date": "2022-02-27 00:00:00 +0100",
    





    
    "snippet": "  ⚓백기선 강사님의 live study에 나온 주제들을 혼자 공부하고 정리하여 작성한 글입니다.⚓📌 4주차 목표: Java 제공하는 제어문을 학습하기 소스코드[0] 개요프로그램은 일반적으로 위에서부터 아래 방향으로 실행되는데, 제어 흐름문을 사용하면 실행 흐름을 분리하여 조건에 따라 특정 코드 블록을 실행하도록 할 수 있다.3가지로 나눌 수 있다. ...",
    "content": "  ⚓백기선 강사님의 live study에 나온 주제들을 혼자 공부하고 정리하여 작성한 글입니다.⚓📌 4주차 목표: Java 제공하는 제어문을 학습하기 소스코드[0] 개요프로그램은 일반적으로 위에서부터 아래 방향으로 실행되는데, 제어 흐름문을 사용하면 실행 흐름을 분리하여 조건에 따라 특정 코드 블록을 실행하도록 할 수 있다.3가지로 나눌 수 있다.  의사 결정문(Decision-Making Statements): if-then, if-then-else, switch  반복문(Looping Statements): for, while, do-while  분기문(Branch Statements): break, continue, return[1] 의사 결정문(Decision-Making Statements)if-then  if절의 결과가 true이면 then절을 실행하고, false면 then절을 건너 뛴다.  then절에 구문이 1개면 중괄호({...})를 생략할 수 있다.if (isDeleted) // if clause    // then clause    System.out.println(\"This is already deleted!\");if-then-elseif (isDeleted) // if clause    // then clause    System.out.println(\"This is already deleted!\");else {    deleted = true;    System.out.println(\"Successfully deleted!\");}if-then-elseif-elseint score = 70;char grade;if (score &gt;= 90) {    grade = 'A';} else if (score &gt;= 75) {    grade = 'B';} else if (score &gt;= 60) {    grade = 'C';} else {    grade = 'F';}switch사용가능한 자료형  기본형(Primitive Type)중에서 byte, short, char, int  래퍼 클래스(Wrapper Class)중에서 Byte, Short, Character, Integer  Enum Types      String (Java 7 이상)    case value:: 각각의 경우를 나열  default:: 어느 case에도 속하지 않는 경우 (선택사항)  break: 이후의 case문을 실행하지 않고 switch문 종료🔽 올바르게 작성된 switch문int dayNum = 2;String dayString = \"\";switch (dayNum) {    case 1:        dayString = \"Monday\";        break;    case 2:        dayString = \"Tuesday\";        break;    case 3:        dayString = \"Wednesday\";        break;    case 4:        dayString = \"Thursday\";        break;    case 5:        dayString = \"Friday\";        break;    case 6:        dayString = \"Friday\";        break;    case 7:        dayString = \"Friday\";        break;    default:        System.out.println(\"Invalid number for day\");}    System.out.println(dayString); // \"Tuesday\"🔽 break를 생략하면…  break를 만날 때까지 하위 case문을 거쳐 default문까지 모두 실행된다.int dayNum = 2;String dayString = \"\";switch (dayNum) {    case 1:        dayString = \"Monday\";    case 2:        dayString = \"Tuesday\";    case 3:        dayString = \"Wednesday\";    case 4:        dayString = \"Thursday\";        break;    case 5:        dayString = \"Friday\";        break;}    System.out.println(dayString); // \"Thursday\"🔽 여러 case 묶어 표현하기int dayNum = 6;String dayString = \"\";switch (dayNum) {    case 1: case 2: case 3: case 4: case 5:        dayString = \"Weekday\";        break;    case 6: case 7:        dayString = \"Weekend\";        break;    default:        System.out.println(\"Invalid number for day\");}    System.out.println(dayString); // \"Weekend\"[2] 반복문(Looping Statements)while  while문의 조건이 true이면 반복 수행한다.int count = 1;while (count &lt; 3) {    System.out.println(\"The count: \" + count);    count++;}The count: 1The count: 2do-while  do문을 먼저 실행한 후, while문의 조건이 true이면 다시 do문을 반복 수행한다.  do문이 최소 1회 실행되는 것을 보장한다.int count = 4;// while문System.out.println(\"========== while ==========\");while (count &lt; 3) {    System.out.println(\"The count: \" + count);    count++;}// do-while문System.out.println(\"========== do-while ==========\");do {    System.out.println(\"The count: \" + count);    count++;} while (count &lt; 3)========== while ==================== do-while ==========The count: 4forfor (initialization ; termination ; increment) {    statements}  initialization은 최초 1회만 실행된다.  termination가 true면 반복 수행한다.  increment는 매 라운드 후에 실행된다.for (int count = 3 ; count &gt; 0 ; count--) {    System.out.println(\"The count: \" + count);}🔽 각각의 요소는 문법적으로 생략이 가능하다.int count = 3;for (;;) {    if (count &gt; 0) {        System.out.println(\"The count: \" + count);        count--;    } else {        break;    }}The count: 3The count: 2The count: 1Enhanced for  Collections나 배열([])에 사용할 수 있다.int[] nums = {1, 2, 3};for (int num : nums) {    System.out.println(\"The number: \" + num);}The number: 1The number: 2The number: 3forEach  Java 8 이상부터 사용 가능하다.  Collections에 사용 가능하다.List&lt;Integer&gt; list = Arrays.asList(1, 2, 3);list.forEach(n -&gt; System.out.println(\"The number: \" + n));The number: 1The number: 2The number: 3[3] 분기문(Branching Statements)break  반복문을 종료할 때 사용한다.  unlabeled break와 labeled break가 있다.예제로 비교해보면 이해가 쉽다.unlabeled break  break를 하면 가장 안쪽에 위치한 switch, for, while, do-while를 종료한다.label:    ... // statements    break label;int[][] nums = { { 32, 87},                 { 12, 1076},                 { 622, 127 } };int searchfor = 12;int i;int j = 0;boolean isfound = false;for (i = 0; i &lt; nums.length; i++) {    for (j = 0; j &lt; nums[i].length; j++) {        if (nums[i][j] == searchfor) {            isfound = true;            break;        }    }}if (isfound) {    System.out.println(\"Found \" + searchfor + \" at \" + i + \", \" + j);} else {    System.out.println(searchfor + \" not in the array\");}Found 12 at 3, 2  안쪽 for문만 종료되기 때문에 찾고자하는 값을 찾은 이후 i = 1에 대한 탐색은 건너뛰지만 i = 2는 실행된다. (예제에서 보면 32 -&gt; 87 -&gt; 12 -&gt; 622 -&gt; 127에 대해서 탐색함)labeled break  break label_name를 하면 바깥쪽에 위치한 실행문을 종료한다.int[][] nums = { { 32, 87},                 { 12, 1076},                 { 622, 127 } };int searchfor = 12;int i;int j = 0;boolean isFound = false;search:    for (i = 0; i &lt; nums.length; i++) {        for (j = 0; j &lt; nums[i].length; j++) {            if (nums[i][j] == searchfor) {                isFound = true;                break search;            }        }    }if (isFound) {    System.out.println(\"Found \" + searchfor + \" at \" + i + \", \" + j);} else {    System.out.println(searchfor + \" not in the array\");}Found 12 at 1, 0  (1, 0)에서 찾고자하는 값을 찾은 후 for문이 바로 종료되는 것을 확인할 수 있다.continue  반복문에서 현재 라운드를 넘길(skip) 때 사용한다.  unlabeled continue와 labeled continue가 있다.🔽 oracle - labeled continue 예제String string = \"search super substring\";String searchTerm = \"sub\";boolean isFound = false;int max = string.length() - searchTerm.length();search:    for (int i = 0; i &lt;= max; i++) {        int n = searchTerm.length();        int j = i;        int k = 0;        while (n-- != 0) { // searchTerm의 길이 만큼 순회하면서            if (string.charAt(j++) != searchTerm.charAt(k++)) { // searchTerm의 문자 하나하나씩 비교하여 다르면                continue search; // 다음 i로 이동            }        }        isFound = true;        break search; // 바깥쪽 for문 종료    }    System.out.println(isFound ? \"Found it\" : \"Didn't find it\");return  값을 반환하거나return i;  계산 값을 반환하거나return i++;  아무것도 반환하지 않을 수 있다.(메서드 리턴타입이 void일 때 사용)return;🚧과제 추가중🚧참고  https://docs.oracle.com/javase/tutorial/java/nutsandbolts/flow.html"
  },
  
  {
    "title": "[Java Live Study] 3. 연산자(Operator)",
    "url": "/posts/3-java-operator/",
    "categories": "Java",
    "tags": "☕Java, Java-Live-Study",
    "date": "2022-02-18 00:00:00 +0100",
    





    
    "snippet": "  ⚓백기선 강사님의 live study에 나온 주제들을 혼자 공부하고 정리하여 작성한 글입니다.⚓📌 3주차 목표: Java의 다양한 연산자 학습하기 소스코드[0] 용어  연산자: 특정한 연산을 수행하고 결과를 반환하는 기호이다.  피연산자: 연산의 대상  단항연산자: 피연산자 1개를 필요로 하는 연산자  이상연산자: 피연산자 2개를 필요로 하는 연산...",
    "content": "  ⚓백기선 강사님의 live study에 나온 주제들을 혼자 공부하고 정리하여 작성한 글입니다.⚓📌 3주차 목표: Java의 다양한 연산자 학습하기 소스코드[0] 용어  연산자: 특정한 연산을 수행하고 결과를 반환하는 기호이다.  피연산자: 연산의 대상  단항연산자: 피연산자 1개를 필요로 하는 연산자  이상연산자: 피연산자 2개를 필요로 하는 연산자  삼항연산자: 피연산자 3개를 필요로 하는 연산자[1] 산술 연산자(Arithmetic Operator)            연산자      의미                  +      더하기(Addition) 혹은 문자열 String concat              -      빼기(Subtraction)              *      곱하기(Multiplication)              /      나누기(Division)              %      나머지(Remainder)      public class ArithmeticOperator {    private int i1 = 10;    private int i2 = 50;    private int i3 = 100;    @Test    public void numericAdditionOperator() {        Assertions.assertEquals(60, i1 + i2);    }    @Test    public void stringAdditionOperator() {        Assertions.assertEquals(\"HelloWorld\", \"Hello\" + \"World\");        Assertions.assertEquals(\"HelloWorld1050\", \"Hello\" + \"World\" + i1 + i2); // HelloWorld60이 아님에 주의!    }    @Test    public void subtractionOperator() {        Assertions.assertEquals(40, i2 - i1);        Assertions.assertEquals(-50, i2 - i3);    }    @Test    public void multiplyOperator() {        Assertions.assertEquals(500, i1 * i2);    }    @Test    public void divisionOperator() {        Assertions.assertEquals(5, i2 / i1);        Assertions.assertEquals(14, 100 / 7);    }    @Test    public void remainderOperator() {        Assertions.assertEquals(0, i2 % i1);        Assertions.assertEquals(2, 100 % 7);    }}[2] 비트 연산자(Bitwise Operator)            연산자      의미                  &amp;      AND              |      (Inclusive) OR              ^      Exclusive OR                  x      y      x&amp;y      x|y      x^y                  0      0      0      0      0              0      1      0      1      1              1      0      0      1      1              1      1      0      1      0      public class BitwiseOperator {    private int i1 = 14; // 1110(2)    private int i2 = 3; // 0011(2)    @Test    public void andOperator() {        Assertions.assertEquals(2, i1 &amp; i2); // 8 = 0010(2)    }    @Test    public void inclusiveOrOperator() {        Assertions.assertEquals(15, i1 | i2); // 13 = 1111(2)    }    @Test    public void exclusiveOrOperator() {        Assertions.assertEquals(13, i1 ^ i2); // 5 = 1101(2)    }    }쉬프트 연산자(Bit Shift Operator)🚧Unsigned Shift Operator🚧[3] 관계 연산자(Relational Operator)            연산자      역할                  x == y      x와 y가 같다              x != y      x와 y가 같지 않다              x &gt; y      x가 y보다 크다              x &gt;= y      x가 y보다 크거나 같다              x &lt; y      x가 y보다 작다              x &lt;= y      x가 y보다 작거나 같다      public class RelationalOperator {    int i1 = 1;    int i2 = 10;    @Test    public void relationalOperator() {        Assertions.assertFalse(i1 == i2);        Assertions.assertTrue(i1 != i2);        Assertions.assertFalse(i1 &gt; i2 | i1 &gt;= i2);        Assertions.assertTrue(i1 &lt; i2);        Assertions.assertTrue(i1 &lt;= i2);    }}[4] 논리 연산자(Logical Operator)  Conditional Operator이라고도 한다.            연산자      의미                  &amp;&amp;      AND              ||      OR      🚧 비트 연산자의 AND(&amp;) 혹은 OR(|)와 혼동하지 않도록 주의해야한다.[5] instanceof  타입 비교 연산자(Type Comparison Operator)로 객체가 특정 타입인지 확인할 수 있다..  true 혹은 false를 반환한다.object_reference instanceof typepublic abstract class Creature { ... }public abstract class Plant extends { ... }public class Cactus extends Plant { ... }public class TypeComparisonOperator {    @Test    public void typeComparisonOperator() {        Cactus c = new Cactus(12, true);        Assertions.assertTrue(c instanceof Cactus);        Assertions.assertTrue(c instanceof Plant);        Assertions.assertTrue(c instanceof Creature);    }}[6] 대입 연산자(Assignment Operator)  대입 연산자 =는 피연산자에 값을 대입할 때 사용한다.  다른 연산자와 결합하여 사용할 수도 있다.variable = value🔽 다른 연산자와 결합된 형태            연산자      의미                  x += y      x = x + y              x -= y      x = x - y              x *= y      x = x * y              x /= y      x = x / y              x %= y      x = x % y              x &amp;= y      x = x &amp; y              x ^= y      x = x ^ y              x |= y      x = x | y              x &lt;&lt;= y      x = x « y              x &gt;&gt;= y      x = x » y              x &gt;&gt;&gt;= y      x = x »&gt; y      [7] 화살표 연산자(Arrow Operator)  화살표 연산자 -&gt;는 Java 8에서 람다 표현식이 도입되면서부터 사용되기 시작했다.parameter -&gt; expression                    // valid(parameter1, parameter2) -&gt; expression     // valid(parameter1), parameter2) -&gt; {code block}  // validList&lt;Integer&gt; numList = new ArrayList&lt;&gt;();numList.add(1);numList.add(2);numList.add(3);numList.forEach((n) -&gt; System.out.println(n));---------- 실행 결과 ----------123[8] 삼항 연산자(Ternary Operator)  삼항 연산자 ? :는 경우에 따라 if문을 대신하여 간략하게 사용할 수 있다.conditional ? true_expression : false_expression int score = 20;Boolean passed = score &gt;= 60 ? true : false;System.out.println(passed);// if문으로 표현하면int score = 20;Boolean passed;if (score &gt;= 60) {    passed = true;} else {    passed = false;}[9] 연산자 우선순위            우선순위      연산자 종류      예시                  1      후위 연산자      v++, v--              2      단항 연산자      ++v, --v, +v, -v, ~, !              3      산술 연산자(곱셈관련)      *, /, %              4      산술 연산자(덧셈관련)      +, -              5      관계 연산자(부등호)      &lt;, &gt;, &lt;=, &gt;=, instanceof              6      관계 연산자(등호)      ==, !=              7      비트 연산자(AND)      &amp;              8      비트 연산자(XOR)      ^              9      비트 연산자(OR)      |              10      논리 연산자(AND)      &amp;&amp;              11      논리 연산자(OR)      ||              12      삼항 연산자      ? :              13      대입 연산자      =, +=, -=, *=, /=, %=, &amp;=, ^=, !=, &lt;&lt;=, &gt;&gt;=, &gt;&gt;&gt;=      [10] Switch 연산자  Switch 연산자는 기존에 존재하던 switch 조건문과 문법이 유사하며, Java 12부터 사용이 가능하다.  : 대신 -&gt;를 사용할 수 있다. (statement가 여러개면 {}와 같이 사용한다.)  break가 필요 없다.  yield를 사용해 값을 대입한다.🔽 switch 조건문int option = 1;String language;switch(option) {    case 1:        language = \"KO\";        break;    case 2:        language = \"EN\";        break;    case 3:        language = \"DE\";        break;    default:        language = \"N/A\";        break;}🔽 switch 연산자int option = 1;String language = switch(option) {    case 1:        yield \"KO\";    case 2:        yield \"EN\";    case 3:        yield \"DE\";}// 혹은 이렇게도 표현 가능String language = switch(option) {    case 1 -&gt; { yield \"KO\"; }    case 2 -&gt; { yield \"EN\"; }    case 3 -&gt; { yield \"DE\"; }}참고  https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html  https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html  https://docs.oracle.com/en/java/javase/13/language/switch-expressions.html"
  },
  
  {
    "title": "[Java Live Study] 2. 자료형(Data Type), 변수(Variable), 배열(Array)",
    "url": "/posts/2-java-data-type-and-variable-and-array/",
    "categories": "Java",
    "tags": "☕Java, Java-Live-Study",
    "date": "2022-02-17 00:00:00 +0100",
    





    
    "snippet": "  ⚓백기선 강사님의 live study에 나온 주제들을 혼자 공부하고 정리하여 작성한 글입니다.⚓📌 2주차 목표: Java의 자료형, 변수 그리고 배열 사용하는 방법 익히기[1] 기본형(Primitive Type)  Java의 자료형은 기본형과 참조형으로 나눌 수 있고, 기본형(8개)을 제외한 나머지는 모두 참조형이라 할 수 있다.  고정된 크기가 ...",
    "content": "  ⚓백기선 강사님의 live study에 나온 주제들을 혼자 공부하고 정리하여 작성한 글입니다.⚓📌 2주차 목표: Java의 자료형, 변수 그리고 배열 사용하는 방법 익히기[1] 기본형(Primitive Type)  Java의 자료형은 기본형과 참조형으로 나눌 수 있고, 기본형(8개)을 제외한 나머지는 모두 참조형이라 할 수 있다.  고정된 크기가 할당된다.  스택(Stack)에 할당된다.  변수 안에는 값 자체가 저장된다.int i = 5;System.out.println(i); ===== 실행 결과 =====5기본형의 종류Java 기본형 변수에는 8가지가 있다.            Type      Size      Range      Default                  byte      1 byte      [-128, 127]      0              short      2 bytes      [-32,768, 32,767]      0              signed int      4 bytes      [-231, 231-1]      0              unsigned int      4 bytes      [0, 232-1]      0              signed long      8 bytes      [-263, 263-1]      0L              unsigned long      8 bytes      [0, 264-1]      0L              float      4 bytes      [1.4E-45, 3.4028235E38]      0.0f              double      8 bytes      [4.9E-324, 1.7976931348623157E308]      0.0d              boolean      1bit      true / false      false              char      2 bytes      [‘\\u0000’(0), ‘\\uffff’(65,535)]      ‘\\u0000’(공백 1칸)      [2] 참조형(Reference Type)  크기가 정해져 있지 않다.  힙(Heap)에 할당된다.  변수 안에는 메모리의 주소가 저장된다.Person p1 = new Person(\"Alice\", 25);System.out.println(p1);===== 실행 결과 =====Person@245b4bdc참조형 변수의 메모리 할당Person p1 = new Person(\"Alice\", 25);를 입력할 때 메모리 구조는 어떻게 되는지 그림으로 표현해보았다.스택에 p1 변수가 생성되고, 초기화되지 않았기 때문에 아직 null 값을 가지고 있다.힙에 Person 객체가 생성되고 p1에는 객체의 주소가 저장된다. (주소는 1000이라 가정했다.)스택에 있는 변수 p1이 힙에 있는 Person 객체를 참조한다고 말하고, 가리킨다고 표현하기도 한다. 그림으로는 화살표로 표현한다.[3] 리터럴(Literal)리터럴은 기본형 변수에 값을 대입할 때 대입연산자(=)를 기준으로 우변에 사용되는 고정 값을 의미한다.boolean result = true; // true가 리터럴char ch = 'a'; // 'a'가 리터럴int i = 100; // 100이 리터럴숫자형 리터럴에 언더스코어(_) 사용하기실생활에서 긴 숫자에 3자리씩 끊어서 콤마(,)를 찍듯이 Java7부터는 언더스코어(_)를 사용하여 가독성을 높일 수 있다.  숫자형 데이터 타입이면 사용 가능하다.  꼭 3자리씩 나누어야 하는 것은 아니다.  유효하지 않은 경우          숫자 리터럴 맨 앞이나 맨 뒤에 사용 불가능      소숫점 앞뒤에 사용 불가능      타입을 명시해주는 접미사(예. float에 F, long에 L) 앞에 사용 불가능      숫자를 String으로 입력하는 경우 사용 불가능      // error: 1번에 해당long l = _123000L;int i = 456000_;// error: 2번에 해당float f = 12._345f;float f = 12_.345f;// error: 3번에 해당double d = 89.000_d;// error: 4번에 해당int i = Integer.parseInt(\"650_000\");// ok int i = 9_____7;[4] 변수 선언(Variable Declaration)  변수 선언은 메모리에 공간을 할당하는 것을 의미한다.  선언 방법: [데이터 타입] [변수명]int i;Person p;[5] 변수 초기화(Variable Initialization)  변수 초기화는 할당한 메모리 공간에 처음으로 유의미한 값을 넣는 것을 말한다.  지역변수는 반드시 초기화해야한다.i = 100; // i가 위에서처럼 이미 선언한 변수라고 가정하면p = new Person();5-1) 명시적 초기화(Explicit Initialization)  명시적 초기화는 선언과 동시에 초기화하는 것을 의미한다.int i = 100;Person p = new Person();5-2) 생성자(Constructor)로 초기화public class Person {  private String name;  private int age;  Person() {}  Person(String name, int age) {    this.name = name;    this.age = age;  }}Person p = new Person();Person p = new Person(\"Alice\", 20);5-3) 초기화 블럭(Initialization Block)으로 초기화(1) 클래스 초기화 블럭  클래스 변수(static 변수)의 초기화에 사용된다.  메모리에 로드될 때 딱 한 번만 수행된다.(2) 인스턴스 초기화 블럭  인스턴스 변수(non-static 변수)의 초기화에 사용된다.  인스턴스를 생성할 때마다 수행된다.  생성자보다 먼저 수행된다.  여러 개의 생성자에 공통되는 부분을 묶어서 처리하기에 유용하다.public class Person{  static {} // 클래스 초기화 블럭  {} // 인스턴스 초기화 블럭}🔽 Person 예제public class Person{  // 인스턴스 변수  String name;  int age;  boolean dead;  // 클래스 변수  static int total;  // 클래스 초기화 블럭  static{    total = 0;  }  // 인스턴스 초기화 블럭  {    dead = false;    total++;  }  Person() {    age = 1;    //dead = false; // 코드 중복 =&gt; 인스턴트 초기화 블럭으로    //total++;   }  Person(String name, int age) {    this.name = name;    this.age = age;    //dead = false; // 코드 중복 =&gt; 인스턴트 초기화 블럭으로    //total++;   }}[6] 변수의 유효범위(Scope)와 수명(Lifetime)  변수의 유효범위는 변수에 접근가능한 영역적 범위를 의미한다.  변수의 수명은 변수가 메모리에 생존해 있는 기간을 의미한다.            변수 종류      선언 위치      변수 유효범위      생성시기      소멸시기                  인스턴스 변수(Instance Variable)      클래스 영역      인스턴스 내      인스턴스 생성 시      참조하는 변수 없을 시              클래스 변수(Class Variable)      클래스 영역      해당 클래스 내      메모리에 로드 시      프로그램 종료 시              지역변수(Local Variable)      메서드 영역      메서드 내      변수 선언 시      해당 메서드 끝날 시      [7] 형변환(Type Conversion)  형변환은 데이터 타입을 변환시키는 것이다.  크게 두 종류로 나눌 수 있는데 다양하게 불리고 있으니 동의어를 알아두는 게 좋을 것 같다.7-1) Type Promotion= Widening Conversion= Upcasting= 자동 형변환= 묵시적(Implicit) 타입 변환  표현할 수 있는 값의 범위가 작은 데이터 타입에서 큰 데이터 타입으로의 형 변환  값의 손실 없이 변환된다.  컴파일러에 의해 자동으로 수행된다.7-2) Type Casting= Narrowing Conversion= Downcasting= 강제 형변환= 명시적(Explicit) 타입 변환  표현할 수 있는 값의 범위가 큰 데이터 타입에서 작은 데이터 타입으로의 형 변환  값의 손실이 발생할 수 있다.  괄호 안에 변환되고자 하는 타입을 넣어 변환한다.int i = 128;byte b = (byte) i;[8] 타입 추론(Type Inference)  타입 추론은 컴파일러가 추론 알고리즘에 따라 타입을 결정하는 것이다.  타입 추론은 Generics를 지원하는 용도로 사용되다가, Lambda를 도입하면서 개선되었다.🚧 Generics랑 Lambda 공부하고 돌아와서 타입추론 내용 보충하기 🚧var  var는 지역 변수로만 선언될 수 있으며, 지역 변수의 타입 추론을 위해 사용된다.  컴파일러가 변수의 초기값으로 타입을 추론해 명시해두기 때문에 변수를 읽을 때마다 추론을 위한 연산을 하지 않는다.  명시적 초기화(선언과 동시에 초기값을 부여하는 것)를 해야한다.  null, 배열, 람다 표현식으로 초기화할 수 없다.[9] 1차 배열(1-Dimensional Array) 선언선언int[] array1D; // validint array1D[]; // valid초기화array1D = new int[5]; // {0, 0, 0, 0, 0}array1D = {1, 2, 3}; // 물론 선언과 동시에 초기화도 가능int[] array1D = new int[5];[10] 2차 배열(2-Dimensional Array) 선언선언int[][] array2D; // validint[] []array2D; // validint[] array2D[]; // validint [][]array2D; // validint []array2D[]; // validint array2D[][]; // valid🔽 동시에 2개의 변수를 선언할 때int[][] array1, array2; // 둘다 int[][]int[] array1[], array2; // array1은 int[][], array2는 int[]초기화array2D = new int[2][3]; // { {0, 0, 0}, {0, 0, 0} }array2D = { {1, 2, 3}, {11, 22, 33} }; // 물론 선언과 동시에 초기화도 가능int[][] array2D = new int[2][3];참고  https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html  http://net-informations.com/faq/general/valuetype-referencetype.htm  https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html  https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html  https://www.baeldung.com/java-10-local-variable-type-inference  https://www.knowprogram.com/java/multidimensional-array-java/"
  },
  
  {
    "title": "[Jekyll Blog] 댓글&좋아요 기능 추가하기(feat. Giscus)",
    "url": "/posts/add-comments-and-likes-with-giscus/",
    "categories": "Jekyll-Blog",
    "tags": "🧪Jekyll, 💜Blog, Github-Pages",
    "date": "2022-02-07 00:00:00 +0100",
    





    
    "snippet": "  💎Jekyll + Github Pages로 개발 블로그 만들기 / Minimal-Mistakes 테마 커스터마이징하기💎[1] 💎 Giscus 소개Giscus는 Github Discussion을 기반으로 하는 프로그램이다. Github discussion search API를 이용하여 사용자가 선택한 맵핑 방식에 따라 pathname이나 url 혹은...",
    "content": "  💎Jekyll + Github Pages로 개발 블로그 만들기 / Minimal-Mistakes 테마 커스터마이징하기💎[1] 💎 Giscus 소개Giscus는 Github Discussion을 기반으로 하는 프로그램이다. Github discussion search API를 이용하여 사용자가 선택한 맵핑 방식에 따라 pathname이나 url 혹은 title로 연관된 discussion을 찾고 없으면 Giscus Bot🤖이 새로 생성한다.[2] 💎 Giscus로 바꾼 이유  Discussion 글 자체에 누를 수 있는 reaction도 제공하는데 이를 좋아요 기능처럼 사용할 수 있기 때문이다. (이 기능을 사용하려면 기능 탭에서 메인 포스트에 반응 남기기에 체크해야한다.)  커스텀 테마를 지원하기 때문이다.  ‘댓글’이라는 특성 자체가 Issue보다는 Discussion에 더 적합할 것 같았기 때문이다.  나는 댓글 수가 제로였기 때문에😅 해당사항이 없지만 Issue를 Discussion으로 마이그레이션 할 수 있다고 한다.[3] 💎 Giscus 설정 및 적용Giscus는 한국어 공식 문서를 제공하고 있기 때문에 크게 어렵지 않게 진행할 수 있다.내가 설정한 값들은 아래와 같다.  Discussion 맵핑 방식: pathname(경로)  Discussion 카테고리: 권장사항 처럼 Announcements 타입/이 카테고리에서만 discussion 찾기에 체크  기능: 메인 포스트에 반응 남기기, 댓글 위에 댓글 상자 배치에 체크  테마: Github LightDiscussion 맵핑 방식이나 script 코드를 적용하는 방식은 Utterances와 동일하다. 이전에 작성한 [Jekyll Blog] 댓글 기능 추가하기(feat. Utterances)에 자세하게 설명해두었니 참고할 수 있다.조만간 블로그에 어울리는 💜보라보라한 테마💜를 하나 만들어봐야겠다.참고  Giscus Docs"
  },
  
  {
    "title": "[Java Live Study] 1. JVM Architecture",
    "url": "/posts/1-jvm-architecture/",
    "categories": "Java",
    "tags": "☕Java, Java-Live-Study",
    "date": "2022-02-07 00:00:00 +0100",
    





    
    "snippet": "  ⚓백기선 강사님의 live study에 나온 주제들을 혼자 공부하고 정리하여 작성한 글입니다.⚓📌 1주차 목표: Java 소스 파일(.java)을 JVM으로 실행하는 과정 이해하기[1] JVM이란?Java Virtual Machine의 약자로 자바 가상 머신이라고 불린다.컴퓨터가 이해할 수 있는 것은 0과 1로 이루어진 2진수의 기계어이다. 인간이...",
    "content": "  ⚓백기선 강사님의 live study에 나온 주제들을 혼자 공부하고 정리하여 작성한 글입니다.⚓📌 1주차 목표: Java 소스 파일(.java)을 JVM으로 실행하는 과정 이해하기[1] JVM이란?Java Virtual Machine의 약자로 자바 가상 머신이라고 불린다.컴퓨터가 이해할 수 있는 것은 0과 1로 이루어진 2진수의 기계어이다. 인간이 작성하는 소스 코드를 컴퓨터가 이해하는 언어인 기계어(Machine Code) 혹은 바이너리 코드(Binary Code)로 변환하는 과정을 컴파일(Compile)이라고 한다.운영체제마다 요구하는 기계어가 다르기 때문에 Windows에서 컴파일해서 변환된 기계어를 Linux는 이해하지 못한다. 하지만 JVM은 어떤 운영체제에서든 프로그램을 실행할 수 있도록 해준다. \"Write Once. Run Anywhere.\" JVM의 짧은 이 슬로건이 위 설명을 대신해준다.[2] JVM 환경에서의 Compile &amp; ExecutionC와 Java 비교C와 Java로 작성된 각각의 소스 코드가 컴파일되고 실행되는 과정을 비교해본다.  C: 컴파일러가 소스 코드(.c)를 기계어를 포함하는 오브젝트 파일(.obj)로 변환한다. 링커가 오브젝트 파일을 통합해 하나의 실행가능한 파일(.exe)로 만든다.  Java: 컴파일러가 소스 코드(.java)를 바이트코드를 포함하는 클래스파일(.class)로 변환한다직접 해보기Hello World 프로그램을 작성하고 터미널을 통해 직접 컴파일하고 실행해본다.Java 코드 작성하기🔽 HelloWorld.javapublic class HelloWorld {    public static void main(String[] args) {        System.out.println(\"Hello World!\");    }}컴파일하기javac HelloWorld.java에러 없이 성공했다면 같은 위치에 HelloWorld.class가 만들어진다.실행하기java HelloWorld🛑java.lang.ClassNotFoundException🛑: HelloWorld.class를 찾을 수 없을 때 ClassNotFoundException이 발생한다.   1️⃣.class파일이 정말 만들어졌는지 확인해본다.2️⃣해당 파일이 있는 디렉토리에서 명령어를 실행한 것이 맞는지 확인해본다.3️⃣1번도 2번도 아니라면 java -cp [class 파일이 있는 경로] 명령어로 classpath를 명시하여 실행해본다.[3] Byte Code(바이트코드)바이트코드는 JVM이 이해할 수 있는 언어이다. 바이트코드를 JVM 위에서 실행하면, 실행환경에 맞추어 JVM이 바이트코드를 알맞은 형태의 기계어로 변환해준다. Java뿐 만 아니라 Groovy, Scala, Clojure 등 바이트코드로 컴파일이 가능한 언어라면 어느 운영체제 환경이던지 JVM이 설치되어 있기만 하면 해당 언어로 작성한 프로그램을 어디서든 실행할 수 있게 된다.[4] JVM 환경 전체 프로세스JVM이 어떤 구조인지는 아래에서 자세히 설명할 것이기 때문에 이를 제외하고 특징을 나열해본다.  컴파일타임과 런타임으로 나뉘어져 있고, JVM은 런타임에 속해 있다.  컴파일타임에서는 Java 소스 코드(.java)를 javac 명령어를 사용해 바이트코드(.class)를 변환한다.  런타임에서는 바이트코드(.class)를 java 명령어를 사용해 JVM이 실행환경에 알맞게 해석하도록 한다.[5] JVM 구성JVM은 Class loader, Runtime data area, Execution engine 세 가지 영역으로 구성되어 있다.Class LoaderLoadingLoading은 세 종류의 class loader에 의해 진행된다.  Bootstrap class loader: 미리 컴파일된 신뢰할 수 있는 클래스 파일이 들어 있는 RT.jar에서 클래스 파일을 메모리로 로드한다.  Extension class loader: 추가적인 클래스 파일을 /jre/lib/ext/에서부터 메모리로 로드한다.  Application class loader: 프로그래머가 작성한 어플리케이션 파일을 메모리로 로드한다.LinkingLinking은 세 단계로 구성된다.  Verify: 바이트코드 클래스 파일이 표준에 부합하는지 검증한다.  Prepare: 정적 변수를 위한 메모리가 할당되고, 변수의 디폴트 값이 지정된다.  Resolve: symbolic reference가 actual reference로 교체된다.(실제 물리적인 메모리 주소를 가리키게 된다.)🎓Symbolic Reference🎓: symbolic reference는 논리적 참조이다. 즉, 객체가 참조하는 실제 메모리 주소를 가리키는 것이 아니라 객체 자체를 반환한다.Initialization  정적 변수에 실제 값이 할당된다.  Static initializer(정적 초기자)가 실행된다.🎓Static Initializer🎓: static initializer는 프로그램을 실행할 때 단 한 번만 실행이 된다. 1️⃣클래스의 객체를 생성하거나, 2️⃣객체가 아직 생성되지 않았더라도 static 멤버 변수나 static 멤버 함수에 최초 접근할 경우가 해당된다.Runtime Data Area  Method Area: 클래스 데이터가 여기 저장된다. (Class Employee{...})  Heap Memory: 객체와 인스턴스 변수가 저장된다. (new Employee())  Stack Memory: 지역 변수, 연산자 스택, 프레임 데이터(예외 발생, 일반 메서드 반환 등 담당)가 저장된다.  PC Register: 현재 실행되는 명령어가 저장된다.  Native Method Stacks: 네이티브 메서드에 대한 정보가 저장된다.JVM Execution Engine  Interprter: 클래스 파일이나 바이트코드를 한줄씩 읽는다. 문제는 같은 메서드가 여러 번 호출되면, 인터프리터는 해당 줄을 도 다시 해석한다.  JIT(Just In Time) compiler: 인터프리터의 문제를 극복하는 것을 돕는다. 메서드가 반복적으로 호출되면 JIT 컴파일러는 바이트코드를 네이티브 코드로 컴파일한다. 이 네이티브 코드는 반복적으로 호출되는 메서드에 바로 사용된다.          Intermediate code generator: 중간 코드 생성한다.      Code optimizer: 중간 코드의 성능을 개선한다.      Target code generator: 중간 코드를 네이티브 코드로 변환한다.      Profiler: 반복적으로 호출되는 지점을 찾는다.        Garbage collector: 더이상 사용하지 않는 객체를 제거한다.  Java native method interface: 네이티브 라이브러리와 상호작용하여 JVM 실행 엔진이 이를 사용할 수 있도록 한다.[6] JRE와 JDK  JRE(Java Runtime Environment): JVM + 표준 라이브러리  JDK(Java Development Kit): JRE + 개발자를 위한 도구(javac, jdb, jar 등)  프로그램 실행하기 위해서는 JRE만 설치해도 충분하지만, 개발을 목표로 한다면 JDK를 설치해야한다.  Java 언어 자체는 무료이지만, JDK는 어느 것을 사용하느냐에 따라 무료로 사용할 수도 있고, 유료로 사용해야할 수도 있다. (Oracle JDK는 상업적으로 이용 시 유료, Open JDK는 무료 등)참고  https://www.youtube.com/watch?v=QHIWkwxs0AI  https://www.youtube.com/watch?v=G1ubVOl9IBw  https://blog.jamesdbloom.com/JVMInternals.html"
  },
  
  {
    "title": "[Jekyll Blog] favicon 생성 및 설정",
    "url": "/posts/set-favicon/",
    "categories": "Jekyll-Blog",
    "tags": "🧪Jekyll, 💜Blog, Github-Pages",
    "date": "2022-02-01 00:00:00 +0100",
    





    
    "snippet": "  💎Jekyll + Github Pages로 개발 블로그 만들기 / Minimal-Mistakes 테마 커스터마이징하기💎[1] favicon 생성favicon 설정을 쉽게 도와주는 사이트들이 있다.  favicon.io: 이미지뿐만 아니라 텍스트나 이모지도 파비콘으로 바꿔주는 사이트  realfavicongenerator: 이미지를 파비콘으로 바꿔주...",
    "content": "  💎Jekyll + Github Pages로 개발 블로그 만들기 / Minimal-Mistakes 테마 커스터마이징하기💎[1] favicon 생성favicon 설정을 쉽게 도와주는 사이트들이 있다.  favicon.io: 이미지뿐만 아니라 텍스트나 이모지도 파비콘으로 바꿔주는 사이트  realfavicongenerator: 이미지를 파비콘으로 바꿔주고 html 코드를 제공해주는 사이트나는 이미지를 직접 만들었기 때문에 첫 번째 사이트는 필요하지 않았지만, 간단하게 텍스트나 이모지를 선택해 파비콘으로 만들고자 한다면 유용할 것 같다.🙃realfavicongenerator에서는 웹 브라우저뿐만 아니라 모바일 아이콘, 데스크탑 아이콘으로 어떻게 표현되는지까지 미리보기로 보여주고, 배경색상도 설정할 수 있다.주의해야할 건 마지막 부분에 파비콘 경로 설정 부분이다. 만약 파비콘을 루트에 저장할 것 아니라면 경로를 설정해주어야한다. 나는 recommended를 무시하고 두 번째 것을 선택하고 경로를 assets/img/favicon로 설정하였다.[2] favicon 적용  다운로드 받은 파비콘 압축을 풀어 위에서 지정한 경로에 옮긴다.  생성된 html 코드를&lt;head&gt;...&lt;/head&gt;사이에 붙여넣는다.지킬 블로그는 큰 뼈대 구조는 똑같지만 테마에 따라 파일 구조가 조금씩 다르기 때문에 해당하는 부분을 잘 찾아서 넣어주어야 한다. 보통 _includes 디렉토리 밑에 header.html 혹은 head.html일 가능성이 높다.내가 사용하는 minimal-mistakes 테마 같은 경우에는 _includes/head/custom.html에 붙여넣으면 된다.[3] favicon 적용 확인Github에 push하기 전에 Jekyll server만 켜도 확인할 수 있다. 타-다!🎉bundle exec jekyll serve"
  },
  
  {
    "title": "[Jekyll Blog] 네비게이션 메뉴 추가하기 (카테고리와 태그 메뉴 만들기)",
    "url": "/posts/add-menu-in-navigation/",
    "categories": "Jekyll-Blog",
    "tags": "🧪Jekyll, 💜Blog, Github-Pages",
    "date": "2022-02-01 00:00:00 +0100",
    





    
    "snippet": "  💎Jekyll + Github Pages로 개발 블로그 만들기 / Minimal-Mistakes 테마 커스터마이징하기💎  상단 네비게이션 바에 카테고리와 태그 메뉴를 추가하는 방법을 알아본다. 응용하여 자기소개, 포트폴리오 등 원하는 메뉴를 추가해도 좋을 것 같다.🌻[1] Navigation에 등록_data/navigation.yml에 메뉴 이름과...",
    "content": "  💎Jekyll + Github Pages로 개발 블로그 만들기 / Minimal-Mistakes 테마 커스터마이징하기💎  상단 네비게이션 바에 카테고리와 태그 메뉴를 추가하는 방법을 알아본다. 응용하여 자기소개, 포트폴리오 등 원하는 메뉴를 추가해도 좋을 것 같다.🌻[1] Navigation에 등록_data/navigation.yml에 메뉴 이름과 눌렀을 때 연결될 url을 작성해준다.🔽 navigation.ymlmain:  - title: \"Category\"    url: /categories  - title: \"Tag\"    url: /tags    ...메뉴에 Category 버튼을 누르면 https://{블로그 주소}/categories로 연결된다는 의미인데, 해당 페이지를 아직 만들지 않았기 때문에 404 에러가 화면에 보일 것이다.[2] Page 만들기  루트 경로 밑에 _pages 디렉토리를 만든다.  _pages 밑에 원하는 이름으로 .md파일을 만든다. (나는 category_archive.md, tag_archive.md로 지정했다.)  아래 코드를 붙여 넣는다.🔽 category_archive.md---title: \"Category\"layout: categoriespermalink: /categoriesauthor_profile: true---🔽 tag_archive.md---title: \"Tag\"layout: tagspermalink: /tagsauthor_profile: true---  title: 블로그에서 Category 메뉴를 눌렀을 때 화면에 보여진다.  layout: minimal-mistakes 같은 경우에는 이미 _layouts에 구현이 다 되어있기 때문에 layout으로 지정만 해주면 된다.  permalink: [[1]](#1-menu-등록)에서 `url`에 적은 값과 같은 값을 넣어줘야한다.  author_profile: Category나 Tag 페이지에서도 좌측 프로필이 보여지게 할 것인지에 대한 여부이다."
  },
  
  {
    "title": "[Leetcode] Leetcode 추천 75문제 정리",
    "url": "/posts/leetcode-top-75/",
    "categories": "Leetcode",
    "tags": "Leetcode, 🔥Problem-Solving",
    "date": "2022-01-30 00:00:00 +0100",
    





    
    "snippet": "  해외 어느 구직 커뮤니티에 올라온 ‘새해 선물 - 당신의 시간을 아껴줄 Leetcode Top 75문제 선별해봄.’글에 나열된 75문제의 문제 번호와 난이도를 찾아서 정리해보았다. 부지런히 풀어야지🤓 문제 풀이 모음집  Difficulty: 🟢(Easy), 🟡(Medium), 🔴(Hard)Array            Status      Nr. ...",
    "content": "  해외 어느 구직 커뮤니티에 올라온 ‘새해 선물 - 당신의 시간을 아껴줄 Leetcode Top 75문제 선별해봄.’글에 나열된 75문제의 문제 번호와 난이도를 찾아서 정리해보았다. 부지런히 풀어야지🤓 문제 풀이 모음집  Difficulty: 🟢(Easy), 🟡(Medium), 🔴(Hard)Array            Status      Nr.      Title      Difficulty      My Solution                  ✅      1      Two Sum      🟢                     ✅      121      Best Time to Buy and Sell Stock      🟢                     ✅      217      Contains Duplicate      🟢                     ✅      238      Product of Array Except Self      🟡                     ✅      53      Maximum Subarray      🟡      🗝              ✅      152      Maximum Product Subarray      🟡      🗝              ✅      153      Find Minimum in Rotated Sorted Array      🟡      🗝                     33      Search in Rotated Sorted Array      🟡                            15      3Sum      🟡                            11      Container With Most Water      🟡             Binary            Status      No.      Title      Difficulty                         371      Sum of Two Integers      🟡                     191      Number of 1 Bits      🟢                     338      Counting Bits      🟢                     268      Missing Number      🟢                     190      Reverse Bits      🟢      Dynamic Programming            Status      No.      Title      Difficulty                         70      Climbing Stairs      🟢                     322      Coin Change      🟡                     300      Longest Increasing Subsequence      🟡                     1143      Longest Common Subsequence      🟡                     139      Word Break      🟡                     377      Combination Sum 4      🟡                     198      House Robber      🟡                     213      House Robber 2      🟡                     91      Decode Ways      🟡                     62      Unique Paths      🟡                     55      Jump Game      🟡      Graph            Status      No.      Title      Difficulty                         133      Clone Graph      🟡                     207      Course Schedule      🟡                     417      Pacific Atlantic Water Flow      🟡                     200      Number of Islands      🟡                     128      Longest Consecutive Sequence      🟡                     269      Alien Dictionary (Leetcode Premium)      🟡                     261      Graph Valid Tree (Leetcode Premium)      🟡                     323      Number of Connected Components in an Undirected Graph (Leetcode Premium)      🟡      Interval            Status      No.      Title      Difficulty                         57      Insert Interval      🟡                     56      Merge Intervals      🟡                     435      Non-overlapping Intervals      🟡                     252      Meeting Rooms (Leetcode Premium)      🟢                     253      Meeting Rooms 2 (Leetcode Premium)      🟡      Linked List            Status      No.      Title      Difficulty      My Solution                  ✅      206      Reverse Linked List      🟢      🗝              ✅      141      Linked List Cycle      🟢                     ✅      21      Merge Two Sorted Lists      🟢      🗝                     23      Merge K Sorted Lists      🔴                            19      Remove Nth Node From End Of List      🟡                            143      Reorder List      🟡             Matrix            Status      No.      Title      Difficulty                         73      Set Matrix Zeroes      🟡                     54      Spiral Matrix      🟡                     48      Rotate Image      🟡                     79      Word Search      🟡      String            Status      No.      Title      Difficulty                  ✅      3      Longest Substring Without Repeating Characters      🟡                     424      Longest Repeating Character Replacement      🟡                     76      Minimum Window Substring      🔴                     242      Valid Anagram      🟢                     49      Group Anagrams      🟡                     20      Valid Parentheses      🟢                     125      Valid Palindrome      🟢                     5      Longest Palindromic Substring      🟡                     647      Palindromic Substrings      🟡                     271      Encode and Decode Strings (Leetcode Premium)      🟡      Tree            No.      Title      Difficulty                                104      Maximum Depth of Binary Tree      🟢                     100      Same Tree      🟢                     226      Invert Binary Tree      🟢                     124      Binary Tree Maximum Path Sum      🔴                     102      Binary Tree Level Order Traversal      🟡                     297      Serialize and Deserialize Binary Tree      🔴                     572      Subtree of Another Tree      🟢                     105      Construct Binary Tree from Preorder and Inorder Traversal      🟡                     98      Validate Binary Search Tree      🟡                     230      Kth Smallest Element in a BST      🟡                     235      Lowest Common Ancestor of BST      🟢                     208      Implement Trie (Prefix Tree)      🟡                     211      Design Add and Search Words Data Structure      🟡                     212      Word Search 2      🔴      Heap            Status      No.      Title      Difficulty                         23      Merge K Sorted Lists      🔴                     347      Top K Frequent Elements      🟡                     295      Find Median from Data Stream      🔴      "
  },
  
  {
    "title": "[Leetcode/941] Valid Mountain Array 문제 번역/풀이",
    "url": "/posts/leetcode-941-valid-mountain-array/",
    "categories": "Leetcode",
    "tags": "Leetcode, 🔥Problem-Solving, 🟢Easy, Array, ☕Java",
    "date": "2022-01-26 00:00:00 +0100",
    





    
    "snippet": " 문제 바로가기  문제 풀이 모음집🔥 문제정수 배열 arr가 주어지고 이 배열이 산 모양 배열일 때 true를 반환하여라.배열이 산 모양 배열이라는 것은 다음의 경우에만 해당된다.  arr.length &gt;= 3  아래 조건을 만족하는 i(0 &lt; i &lt; arr.length - 1)가 존재한다.          arr[0] &lt; arr...",
    "content": " 문제 바로가기  문제 풀이 모음집🔥 문제정수 배열 arr가 주어지고 이 배열이 산 모양 배열일 때 true를 반환하여라.배열이 산 모양 배열이라는 것은 다음의 경우에만 해당된다.  arr.length &gt;= 3  아래 조건을 만족하는 i(0 &lt; i &lt; arr.length - 1)가 존재한다.          arr[0] &lt; arr[1] &lt; … &lt; arr[i - 1] &lt; arr[i]      arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1]      배열의 어느 원소를 기점으로 좌측은 상승하는 구간, 우측은 하강하는 구간이어야한다. 상승하는 구간과 하강하는 구간이 각각 1번씩 반드시 존재해야한다.🔥 풀이풀이1: 나의 풀이index 0부터 배열끝까지 한 방향으로 탐색해나간다. 현재 값이 이전 값보다 크면 상승구간, 작으면 하강구간이 된다.중간에 탐색을 멈출 조건은 3가지가 있다.  평평한 구간(현재 값 = 이전 값)  상승구간 없이 하강구간  이미 하강구간 지났는데 다시 상승구간이 경우를 제외하고는 배열 끝까지 탐색을 하고, 마지막에 상승구간과 하강구간이 둘 다 존재했을 경우에만 true를 반환한다.class Solution {    public boolean validMountainArray(int[] arr) {        if (arr == null || arr.length &lt; 3) {            return false;        }        int previous = arr[0];        boolean uphill = false;        boolean downhill = false;        for (int i = 1 ; i &lt; arr.length ; i++) {            int current = arr[i];            if (current == previous || (!uphill &amp;&amp; current &lt; previous) || (downhill &amp;&amp; current &gt; previous)) {                return false;            } else if (!downhill &amp;&amp; current &gt; previous) {                uphill = true;            } else if (uphill &amp;&amp; current &lt; previous) {                downhill = true;            }            previous = current;        }        return uphill &amp;&amp; downhill;    }}Runtime: 5msMemory Usage: 51.5MB풀이2: 다른 사람 풀이hi-malik님의 풀이를 가져와봤다.배열을 탐색할 변수를 두 개 선언한다.  left: index 0부터 시작해서 n-1방향으로 진행한다.  right: index n-1부터 시작해서 0방향으로 진행한다.left는 상승구간일 경우에 left++하고, right은 하강구간일 경우에 right--한다. 마지막에 결국 left == right이면 산의 정상이 딱 하나 존재했다는 의미가 되므로 true를 반환한다.class Solution {    public boolean validMountainArray(int[] arr) {        if(arr.length &lt; 3) return false;        int left = 0;        int right = arr.length - 1;        while(left + 1 &lt; arr.length - 1 &amp;&amp; arr[left] &lt; arr[left + 1]) left++;        while(right - 1 &gt; 0 &amp;&amp; arr[right] &lt; arr[right - 1]) right--;        return left == right;    }}Runtime: 3msMemory Usage: 51.7MB"
  },
  
  {
    "title": "[Algorithm] 플로이드 순환 검출 알고리즘(Floyd's Cycle Detection Algorithm)",
    "url": "/posts/floyds-cycle-detection-algorithm/",
    "categories": "Algorithm",
    "tags": "💡Algorithm",
    "date": "2022-01-26 00:00:00 +0100",
    





    
    "snippet": "  a.k.a 토끼와 거북이 알고리즘(Tortoise🐢 &amp; Hare🐇 Algorithm) / Slow &amp; Fast Algorithm[1] 개요  플로이드 순환 검출 알고리즘은 토끼와 거북이 알고리즘 혹은 Slow&amp;Fast 알고리즘이라고도 불린다.  속도를 달리하는 두 개의 포인터를 가지고 순환 구간이 존재하는지, 존재한다면 순환 ...",
    "content": "  a.k.a 토끼와 거북이 알고리즘(Tortoise🐢 &amp; Hare🐇 Algorithm) / Slow &amp; Fast Algorithm[1] 개요  플로이드 순환 검출 알고리즘은 토끼와 거북이 알고리즘 혹은 Slow&amp;Fast 알고리즘이라고도 불린다.  속도를 달리하는 두 개의 포인터를 가지고 순환 구간이 존재하는지, 존재한다면 순환 구간이 어느 노드에서 시작하는지 검출할 수 있다.[2] 동작 방식  거북이는 1칸씩, 토끼는 2칸씩 움직인다.  거북이와 토끼가 만나면 거북이를 출발 지점으로 옮긴다.  거북이와 토끼를 각각 1칸씩 옮긴다.  거북이와 토끼가 다시 만난다.발로 그린 거북이와 토끼를 준비하고 그림으로 표현해보았다.우선 거북이와 토끼가 만날 때까지 거북이는 1칸, 토끼는 2칸씩 움직인다.거북이와 토끼가 만났으면 거북이를 출발 지점으로 옮긴다.거북이와 토끼가 다시 만날 때까지 거북이도 1칸, 토끼도 1칸씩 움직인다.이 알고리즘에서 알 수 있는 것은 크게 두 가지이다.  거북이와 토끼가 만났다면 순환하는 구간이 존재한다.  거북이를 시작 지점으로 옮긴 후 거북이와 토끼가 다시 만나는 지점은 순환 구간이 시작하는 노드이다.[3] 일반화순환 구간이 존재하면 이동 거리와 위치가 비례하지 않아서 사실 제대로 증명하기가 좀 복잡한 것 같다. 명제1은 직관으로 이해할 수 있었지만 명제2는 따로 정리하기 전까지 받아들이기 힘들었다.명제1거북이와 토끼가 만났으면 순환하는 구간이 존재한다.속력이 다른 두 사람이 달리기를 한다고 생각해본다. 이 때 속력은 빨라졌다 느렸졌다 하지 않고 일정하다고 가정한다. 직선트랙이라면 두 사람의 거리는 점점 멀어져 만날 수 없게 되겠지만 원형트랙이라면 둘은 만나게 될 것이다.명제2출발 지점에서부터 순환 구간이 시작하는 지점까지의 거리는 거북이와 토끼가 만난 지점에서부터 순환 구간이 시작하는 지점까지의 거리와 같다.(= 거북이와 토끼가 다시 만나는 지점은 순환 구간의 시작 지점이다.)명제를 말로 풀어 설명하면 복잡해 보이지만 아래 사진에서 빨간 구간과 초록 구간의 길이가 같다는 것을 증명하면 된다.  x: 출발 지점에서부터 순환 구간이 시작하는 지점까지의 거리  y: 순환 구간이 시작하는 지점부터 거북이와 토끼가 만난 지점까지의 거리  K: 순환 구간의 길이  n1: 거북이가 이동한 순환 구간 바퀴 수  n2: 토끼가 이동한 순환 구간 바퀴 수  토끼의 속력은 거북이의 속력의 2배이다.  거북이가 이동한 거리는 x + K*n1 + y  토끼가 이동한 거리는 x + K*n2 + y  토끼는 거북이보다 2배 빠르기 때문에 2(x + K*n1 + y) = x + K*n2 + y  식을 정리하면 x + y = (n2 - n1)K  n2 - n1은 상수이기 때문에 간략히 표현하면 x + y = N*K  한번 더 정리하면 x = N*K - y이고 x는 N바퀴의 순환 길이에서 y를 뺀 것과 같다고 할 수 있고, 순환길이에서 y를 뺀 것은 위 사진의 초록 구간에 해당하기 때문에 명제는 성립한다고 볼 수 있다.[4] 구현🔽 순환 구간의 시작 지점을 구하는 Java 코드(Leetcode 142번 Linked List Cycle2)public ListNode detectCycle(ListNode head) {    if (head == null) return null;            ListNode slow = head; // 거북이    ListNode fast = head; // 토끼    // 순환구간이 존재하는지 판단    boolean hasCycle = false;    while (fast.next != null &amp;&amp; fast.next.next != null) {        slow = slow.next;        fast = fast.next.next;        if (slow == fast) { // 거북이와 토끼가 만났다면            hasCycle = true; // 순환구간은 존재            break;        }    }    if (hasCycle) { // 순환구간이 존재한다면        slow = head; // 거북이를 출발 지점으로 이동        while (slow != fast) { // 거북이와 토끼가 만날때까지 한칸씩 이동            slow = slow.next;            fast = fast.next;        }        return slow;    }    return null;}"
  },
  
  {
    "title": "[VSCode] Leetcode 확장 프로그램",
    "url": "/posts/vscode-extension-for-leetcode/",
    "categories": "VSCode",
    "tags": "VSCode, 🔨Tool",
    "date": "2022-01-24 00:00:00 +0100",
    





    
    "snippet": "  ✨ Visual Studio Code Extension for Leetcode ✨요즘 Leetcode를 열심히 푸는데,,, 풀려고 출석은 매일 하는데,,, 마침 우연히 Github 추천 레포지토리에 떠서 다운받게 된 Extension이다. 너무 멋진 프로그램이라 소개해보고자 한다.🙆‍♀️[1] 다운로드  Visual Studio Code에서 Ext...",
    "content": "  ✨ Visual Studio Code Extension for Leetcode ✨요즘 Leetcode를 열심히 푸는데,,, 풀려고 출석은 매일 하는데,,, 마침 우연히 Github 추천 레포지토리에 떠서 다운받게 된 Extension이다. 너무 멋진 프로그램이라 소개해보고자 한다.🙆‍♀️[1] 다운로드  Visual Studio Code에서 Extensions에 Leetcode라고 검색하면 여러개가 나오는데 나는 다운로드수가 제일 많은 걸로 선택해서 받았다.  해당 확장 프로그램 Github 페이지[2] 실행로그인우선 로그인을 해야 메뉴를 둘러볼 수 있다.좌측에 Leetcode 로고 선택하고, Explorer 상단에 대문버튼🚪을 눌러 로그인한다. Leetcode 계정뿐만 아니라 Github이나 Linkedin 계정으로도 로그인할 수 있다.메뉴 구성커뮤니티 제외하고 Leetcode 홈페이지에서 문제풀 때 제공하는 기능 대부분이 지원된다.      Explorer란에 난이도, 주제, 회사로 분류가 되어있다. Leetcode 홈페이지에서는 문제마다 회사를 확인하려면 프리미엄 구독을 해야하는데 플러그인에서 제공하는 게 신기했다. 버근가…        제출해서 통과한 문제 옆에는 녹색체크✅가 표시되고, 하트🤍를 누르면 Favorite폴더에서 따로 관리할 수 있다.        문제 하나를 클릭해서 Code Now 버튼을 클릭하면 풀이를 시작할 수 있다. 소스코드가 파일 단위로 만들어지기 때문에 파일이 저장되는 폴더를 Github Repository로 관리하고자 할 때 쉽게 직관적으로 가능하다.        하단 바에 LeeCode:아이디 클릭하면 세션을 관리할 수 있다.  테스트&amp;제출테스트 혹은 제출 버튼은 소스 코드 작성하는 곳 밑에 주석처럼 존재하고 있다.Leetcode 홈페이지에서처럼 테스트 케이스를 직접 입력해서 테스트해볼 수 있다.제출해서 통과하면 제출 결과도 보여준다."
  },
  
  {
    "title": "[Java] HttpURLConnection으로 외부 API 호출하기(GET, POST 요청)",
    "url": "/posts/call-api-with-httpurlconnection-in-java/",
    "categories": "Java",
    "tags": "☕Java, 🕸Web, API",
    "date": "2022-01-11 00:00:00 +0100",
    





    
    "snippet": "  Java 라이브러리 HttpURLConnection을 이용하여 외부 API를 호출하고 테스트 서버를 통해 테스트해본다. 소스코드[0] 선수 작업      JSON으로 데이터를 처리할 것이기 때문에 json- simple 라이브러리를 import하는 작업이 필요하다.IntelliJ에 라이브러리 추가하기를 참고할 수 있다.        우선 클래스 구...",
    "content": "  Java 라이브러리 HttpURLConnection을 이용하여 외부 API를 호출하고 테스트 서버를 통해 테스트해본다. 소스코드[0] 선수 작업      JSON으로 데이터를 처리할 것이기 때문에 json- simple 라이브러리를 import하는 작업이 필요하다.IntelliJ에 라이브러리 추가하기를 참고할 수 있다.        우선 클래스 구조는 이렇게 작성했다. 꼭 클래스를 만들거나 함수 안에서 실행해야하는 것은 절대 아니다. 생성자나 Getter, Setter는 여기서는 생략한다. 전체 소스코드는 상단에 소스코드 버튼을 누르면 확인할 수 있다.  🔽 ApiCaller.javapublic class ApiCaller {    private String baseUrl;    private int responseCode;    public JSONObject sendGetRequest() {    }    public void sendPostRequest() {    }[1] GET 요청 보내기🔽 ApiCaller.java &gt; sendGetRequest()1234567891011121314151617181920public JSONObject sendGetRequest() {    JSONObject data = new JSONObject();    try {      URL url = new URL(baseUrl);      HttpURLConnection conn = (HttpURLConnection) url.openConnection();      conn.setRequestMethod(\"GET\"); //Http Method 지정(default가 GET이라 생략가능)      conn.connect();      //InputStream으로 데이터를 읽고, JSONParser를 이용해 JSONObject로 파싱      InputStreamReader inputStreamReader = new InputStreamReader(conn.getInputStream());      JSONParser jsonParser = new JSONParser();      data = (JSONObject) jsonParser.parse(inputStreamReader);      responseCode = conn.getResponseCode(); //응답코드 담기    } catch (IOException | ParseException e) {        e.printStackTrace();    }    return data;}[2] POST 요청 보내기🔽 ApiCaller.java &gt; sendPostRequest()1234567891011121314151617181920public void sendPostRequest(String content) {    try {      URL url = new URL(baseUrl); //URL 객체 생성      HttpURLConnection conn = (HttpURLConnection) url.openConnection();      conn.setRequestMethod(\"POST\"); //Http Method 지정      conn.setRequestProperty(\"Content-Type\", \"application/json\"); //JSON 형태로 데이터 전송      conn.setDoOutput(true); //OutputStream을 통해 데이터를 전송할지 여부      conn.connect();      //OutputStream을 통해 데이터를 전달      OutputStreamWriter outputStreamWriter = new OutputStreamWriter(conn.getOutputStream());      outputStreamWriter.write(content);      outputStreamWriter.flush();      responseCode = conn.getResponseCode(); //응답코드 담기    } catch(IOException e) {        e.printStackTrace();    }}  (라인 8) setDoOutput(true)로 설정하면 request body에 해당하는 내용을 OutputStream을 통해 전달하겠다는 의미이다.[3] 테스트하기Webhook.site 테스트 서버를 통해 HttpURLConnection이 올바르게 동작하는지 간단히 테스트해본다.Webhook.site는 사용자마다 고유 API 서버를 제공해준다. 회원가입 없이 500개까지 요청을 보낼 수 있어서 간단히 연결 테스트를 하기에 적합할 것 같다. 무료버전에서는 POST로 데이터를 전송했을 때 그 데이터를 서버에서 받는 기능은 사용할 수 없다.응답 데이터 설정오른쪽 상단에 Edit 버튼을 누르면 응답으로 내려줄 데이터를 설정할 수 있다.  Default status code: 200  Content Type: application/json  Timeout before response: 5  Response body: {“Description”: “This is api test.”,“Language”: “Java”,}테스트 실행Webhook.site 에서 받은 unique url을 이용하여 테스트를 실행한다.🔽 Main.javapublic class Main {    public static void main(String[] args) {        ApiCaller apiCaller = new ApiCaller(\"https://webhook.site/123456a7-b116-4cd9-951e-0fg2h7di4j56\");        System.out.println(\"//===== GET REQUEST =====//\");        JSONObject data = apiCaller.sendGetRequest();        System.out.println(\"The Data from Server: \" + data);        System.out.println(\"Response Code : \" + apiCaller.getResponseCode());        System.out.println(\"//===== POST REQUEST =====//\");        apiCaller.sendPostRequest(\"Mood: Nerdy\");        System.out.println(\"Response Code : \" + apiCaller.getResponseCode());    }}테스트 결과//===== GET REQUEST =====//The Data from Server: {\"Description\":\"This is api test.\",\"Language\":\"Java\"}Response Code : 200//===== POST REQUEST =====//Response Code : 200참고  HttpURLConnection에 설정할 수 있는 함수들을 잘 설명해둔 사이트: https://www.codejava.net/java-se/networking/how-to-use-java-urlconnection-and-httpurlconnection  https://stackoverflow.com/questions/5725430/http-test-server-accepting-get-post-requests"
  },
  
  {
    "title": "[IntelliJ] 외부 라이브러리 import하기",
    "url": "/posts/import-library-into-intellij/",
    "categories": "Tool",
    "tags": "IntelliJ, 🔨Tool",
    "date": "2022-01-10 00:00:00 +0100",
    





    
    "snippet": "  인텔리제이 빌더를 사용하는 일반 프로젝트에서 외부 라이브러리를 추가하는 방법🚧 네이티브 IntelliJ IDEA 빌더를 사용하는 프로젝트에서 유효한 방법이다. Maven이나 Gradle 같은 빌드 툴을 사용한다면, 빌드 파일을 통해 라이브러리를 추가할 수 있다.두 가지 방법이 있다.  방법 1) jar 파일을 직접 다운로드 받아 프로젝트에 추가하기...",
    "content": "  인텔리제이 빌더를 사용하는 일반 프로젝트에서 외부 라이브러리를 추가하는 방법🚧 네이티브 IntelliJ IDEA 빌더를 사용하는 프로젝트에서 유효한 방법이다. Maven이나 Gradle 같은 빌드 툴을 사용한다면, 빌드 파일을 통해 라이브러리를 추가할 수 있다.두 가지 방법이 있다.  방법 1) jar 파일을 직접 다운로드 받아 프로젝트에 추가하기(혹은 직접 만들어서 jar 파일로 export한 라이브러리를 다른 프로젝트에서 사용하려고 할 경우)  방법 2) Maven을 통한 웹 검색으로 프로젝트에 주입하기[1] 라이브러리 얻기MVNRepository에서 필요한 라이브러리를 검색하고 버전을 선택한다. 나는 예시로 json simple을 검색하고, 1.1.1버전을 선택했다.  방법 1) jar 혹은 bundle을 눌러 jar 파일을 다운로드 한다.  방법 2) dependency의 groupId와 version을 복사한다.[2] 프로젝트에 라이브러리 등록하기IntelliJ &gt; File &gt; Project Structure &gt; 왼쪽 메뉴에서 Libraries &gt; + 버튼  방법 1) Java 선택 &gt; 다운로드 받은 jar 파일 선택      방법 2) From Maven 선택 &gt; 복사한 라이브러리 groupId 혹은 groupId:version 형태로 입력 &gt; 🔍검색 버튼 &gt; OK    여러 개의 모듈이 있는 경우에 라이브러리를 등록하고 나면 라이브러리를 적용할 모듈을 선택하라고 나온다. 여러 개의 모듈을 선택할 수도 있다.  등록된 라이브러리는 프로젝트 폴더 밑 .idea &gt; libraries 에서 확인할 수 있다.  방법 1을 선택하여 jar 파일로 라이브러리를 등록한 경우, 파일을 삭제하면 IntelliJ에서도 삭제된다.[3] 라이브러리 관리하기  라이브러리를 등록한 시점 이후에 추가된 라이브러리를 해제하거나 추가로 다른 모듈에 라이브러리를 적용하고 싶은 경우  하나의 모듈에 대해서 라이브러리 관리할 때: IntelliJ &gt; File &gt; Project Structure &gt; Modules &gt; 모듈 선택 &gt; Dependencies &gt; + 버튼 &gt; Library &gt; 라이브러리 선택  여러 개의 모듈에 대해서 한 번에 라이브러리 관리할 때: Intellij &gt; File &gt; Project Structure &gt; Libraries &gt; 라이브러리에 마우스 오른쪽 클릭 &gt; Add to Modules &gt; 모듈 선택(다중 선택 가능)🎓 정리하자면, 라이브러리 자체를 등록하고 삭제할 때에는 Libraries 탭에서! 등록된 라이브러리를 모듈에 추가하고 삭제하는 것은 Modules 혹은 Libraries 탭에서 가능하나, 여러 개의 모듈에 한꺼번에 적용하고 싶을 때에는 Libraries 탭에서 하는 것이 효율적이겠다!참고  IntelliJ Docs - Libraries인텔리제이에서 라이브러리를 추가할 수 있는 경로도 여러가지고 추가할 수 있는 레벨도 여러가진데 요건 따로 공부해서 정리해야겠다.🤓"
  },
  
  {
    "title": "[Linux] 소유자, 소유그룹 변경하기(chown)",
    "url": "/posts/linux-chown/",
    "categories": "Operating-System",
    "tags": "🐧Linux",
    "date": "2022-01-05 00:00:00 +0100",
    





    
    "snippet": "[1] 문법[root@system]$ chown [-옵션] 소유자[:소유그룹] 파일 경로옵션-R(recursive): 모든 하위 디렉토리와 파일에 적용.예시  test.txt 파일의 소유자를 user로, 소유그룹을 admin으로 변경.    [root@system]$ chown user:admin test.txt        test_d 디렉토리 아래...",
    "content": "[1] 문법[root@system]$ chown [-옵션] 소유자[:소유그룹] 파일 경로옵션-R(recursive): 모든 하위 디렉토리와 파일에 적용.예시  test.txt 파일의 소유자를 user로, 소유그룹을 admin으로 변경.    [root@system]$ chown user:admin test.txt        test_d 디렉토리 아래의 모든 파일과 디렉토리에 대해서 소유자를 user로 변경.    [root@system]$ chown -R user test_d      "
  },
  
  {
    "title": "[HTTP] 멱등성(indempotency)",
    "url": "/posts/idempotency/",
    "categories": "Network",
    "tags": "HTTP, 🕸Web",
    "date": "2022-01-05 00:00:00 +0100",
    





    
    "snippet": "[1] 멱등성이란?  네이버 국어사전에 의하면 멱등성은 ‘연산을 여러 번 적용하더라도 결과값이 달라지지 않는 성질’을 의미한다.🎓 TMI - 冪(덮을 멱) 🎓 네이버 사전에 수학용어라고 나와있길래 ‘엇, 내가 아는 수학용어 중에서도 멱 들어가는 게 있었는데…’ 싶어서 찾아보니까 멱급수였고 두 용어가 같은 한자를 쓰고 있었다. 네이버 한자사전에는 거듭제...",
    "content": "[1] 멱등성이란?  네이버 국어사전에 의하면 멱등성은 ‘연산을 여러 번 적용하더라도 결과값이 달라지지 않는 성질’을 의미한다.🎓 TMI - 冪(덮을 멱) 🎓 네이버 사전에 수학용어라고 나와있길래 ‘엇, 내가 아는 수학용어 중에서도 멱 들어가는 게 있었는데…’ 싶어서 찾아보니까 멱급수였고 두 용어가 같은 한자를 쓰고 있었다. 네이버 한자사전에는 거듭제곱의 의미도 있다고 나온다.[2] 멱등성과 안전함\"HTTP 메서드가 멱등성을 가진다.\"  동일한 요청을 한 번 보낸 것과 여러번 보낸 것이 같은 효과를 보이고, 여러번 요청에 의한 서버의 상태가 동일할 때 HTTP 메서드가 멱등성을 가진다고 말할 수 있다.  멱등성을 가지는 HTTP 메서드: GET, HEAD, PUT, DELETE\"HTTP 메서드가 안전하다.\"  서버의 상태를 바꾸지 않을 때 즉, 읽기 작업을 하는 HTTP 메서드는 안전하다고 말할 수 있다.  안전한 HTTP 메서드: GET, HEAD, OPTIONS  MDN에 보면 모든 HTTP 메서드마다 멱등성과 안전함을 확인할 수 있다.  모든 안전한 메서드는 멱등성을 가지지만, 멱등성을 가진 메서드라고 해서 모두 안전한 것은 아니다.[3] DELETE 메서드와 멱등성  ‘DELETE 메서드는 여러 번 호출하면 응답이 다르게 내려올텐데 멱등성을 가진다고?’ 라는 의문을 품은 저 같은 사람이 있다면 보십쇼…🤧데이터베이스에 저장된 하나의 아이템을 삭제하는 DELETE 메서드를 연달아 3번을 호출한다고 생각해본다. 올바르게 설계되었다면 첫 번째 요청에는 200(OK)을 반환하고, 두 번째 요청부터는 이미 삭제된 아이템에 대해서 요청을 보내기 때문에 404(Not Found)를 반환할 것이다.# 100번 아이템을 삭제한다DELETE items/100/delete HTTP/1.1   #200DELETE items/100/delete HTTP/1.1   #404DELETE items/100/delete HTTP/1.1   #404여기서 중요한 것은 해당 메서드가 멱등성을 가지는 지 따져볼 때 응답의 일치여부가 아닌 첫 번째 요청과 그 이후의 요청을 처리한 후 서버의 상태에 변동이 없는지가 기준이 된다는 것이다.참고  MDN Docs"
  },
  
  {
    "title": "[HTTP] HTTP 개요",
    "url": "/posts/http-overview/",
    "categories": "Network",
    "tags": "HTTP, 🕸Web",
    "date": "2022-01-04 00:00:00 +0100",
    





    
    "snippet": "  HTTP 간략하게 보기[1] HTTP (Hypertext Transfer Protocol)  HTTP는 문자 그대로 HTML 문서와 같은 하이퍼미디어 문서를 전송하기 위한 프로토콜이다.  HTTP의 확장성 덕분에 오늘날에는 하이퍼텍스트 문서 뿐만 아니라 이미지, 비디오, HTML 폼 결과를 전송할 수도 있다.[2] HTTP 특징HTTP는 클라이언트...",
    "content": "  HTTP 간략하게 보기[1] HTTP (Hypertext Transfer Protocol)  HTTP는 문자 그대로 HTML 문서와 같은 하이퍼미디어 문서를 전송하기 위한 프로토콜이다.  HTTP의 확장성 덕분에 오늘날에는 하이퍼텍스트 문서 뿐만 아니라 이미지, 비디오, HTML 폼 결과를 전송할 수도 있다.[2] HTTP 특징HTTP는 클라이언트-서버 프로토콜이다.  클라이언트와 서버가 개별적인 메시지 교환에 의해 통신한다.          요청(requests): 클라이언트에 의해 전송되는 메시지      응답(responses): 서버에서 응답으로 전송되는 메시지      HTTP는 무상태 프로토콜이다.  상태(데이터)를 저장하지 않는다.  사용자와 페이지 사이에 상호작용(예: 쇼핑몰 장바구니)이 필요하다면 HTTP 쿠키를 사용해 세션을 만들어 데이터를 저장할 수 있다.HTTP는 간단하다.  사람이 읽기 쉽다.  HTTP 메시지를 프레임별로 캡슐화하여 간결하게 표현한다.HTTP는 확장가능하다.  HTTP 헤더는 HTTP를 확장하기 쉽게 해준다.[2] HTTP 기반 시스템의 구성요소클라이언트  사용자를 대신하여 동작하는 모든 도구로, 주로 브라우저에 의해 수행된다.  브라우저는 항상 요청을 보낸다.웹 서버  서버는 클라이언트의 요청에 대한 문서를 제공한다.프록시  웹 브라우저와 서버 사이에서는 수많은 컴퓨터와 기계가 HTTP 메시지를 이어 받고 전달한다.  프록시는 어플리케이션 계층에서 동작하는 중간 단계의 컴퓨터 혹은 기계를 의미한다.  프록시를 통해 요청이 변경될 수도 있고 변경되지 않는 경우도 있다.  프록시는 다양한 기능을 수행할 수 있다.          캐싱 (예: 브라우저 캐시)      필터링 (예: 바이러스 필터링, 유해 컨텐츠 필터링)      로드 밸런싱: 여러 서버들이 서로 다른 요청을 처리하도록 허용      인증: 접근 제어      로깅 : 이력 정보 저장      [3] HTTP로 제어할 수 있는 것캐싱(Caching)  서버는 프록시와 클라이언트에게 캐시 대상과 기간을 지시할 수 있다.  클라이언트는 프록시에게 저장된 문서를 무시하라고 지시할 수 있다.인증(Authentication)  HTTP WWW-Authenticate 헤더나 HTTP 쿠키를 사용하여 구현할 수 있다.세션(Session)  HTTP 쿠키를 사용하여 서버 상태와 요청을 연결할 수 있다.Origin 제약 완화  브라우저는 보안상의 이유로 동일한 origin으로부터 온 페이지만이 웹 페이지의 전체 정보에 접근할 수 있도록 한다.  HTTP 헤더를 사용하여 페이지가 동일 origin에서 온 것인지 확인하는 부담을 줄일 수 있다.프록시(Proxy)와 터널링(Tunneling)  HTTP 요청이 네트워크 장벽을 넘기 위해 프록시를 통해 나간다.[4] HTTP 흐름  TCP 연결을 연다.  HTTP 메시지를 전송한다.  서버에 의해 전송된 응답을 읽는다.  연결을 닫거나 다른 요청에 재사용한다.[5] HTTP 메시지 구조요청 메시지123GET / HTTP/1.1Host: developer.mozilla.orgAccept-Language: fr  라인 1의 GET: HTTP 메서드로 클라이언트가 수행하고자 동작을 알 수 있다.  라인 1의 /: 리소스의 경로  라인 1의 HTTP/1.1: HTTP 프로토콜 버전  라인 2-3 전체: HTTP 헤더로 서버에 대한 추가 정보를 나타낸다.응답 메시지12345678HTTP/1.1 200 OKDate: Sat, 09 Oct 2010 14:28:02 GMTServer: ApacheLast-Modified: Tue, 01 Dec 2009 20:18:22 GMTETag: \"51142bc1-7449-479b075b2891b\"Accept-Ranges: bytesContent-Length: 29769Content-Type: text/html  라인 1의 HTTP/1.1: HTTP 프로토콜 버전  라인 1의 200: 상태 코드  라인 1의 OK: 상태 코드 설명  라인 2-8 전체: HTTP 헤더들참고  MDN HTTP 자습서"
  },
  
  {
    "title": "[Jekyll Blog] 댓글 기능 추가하기(feat. Utterances)",
    "url": "/posts/add-comments-with-utterances/",
    "categories": "Jekyll-Blog",
    "tags": "🧪Jekyll, 💜Blog, Github-Pages",
    "date": "2022-01-03 00:00:00 +0100",
    





    
    "snippet": "  💎Jekyll + Github Pages로 개발 블로그 만들기 / Minimal-Mistakes 테마 커스터마이징하기💎[1] 🔮 Utterances 소개특징  오픈 소스다. -&gt; 직접 테마 만들어서 블로그에 적용도 하고 오픈 소스에 기여도 할 수 있다!🤓  가볍다.  광고 없이 무료다.동작방식  Github Issue 기반으로 모든 댓글 데이...",
    "content": "  💎Jekyll + Github Pages로 개발 블로그 만들기 / Minimal-Mistakes 테마 커스터마이징하기💎[1] 🔮 Utterances 소개특징  오픈 소스다. -&gt; 직접 테마 만들어서 블로그에 적용도 하고 오픈 소스에 기여도 할 수 있다!🤓  가볍다.  광고 없이 무료다.동작방식  Github Issue 기반으로 모든 댓글 데이터가 Github Issue에 저장된다.  Github issue search API를 이용하여 사용자가 선택한 이슈 맵핑 방식에 따라 url이나 pathname 혹은 title로 연관된 이슈를 찾고 이슈가 없으면 Utterance bot🤖이 새로 생성해준다.[2] 🔮 Utterances 설정Utterances 공식페이지에서 옵션을 선택하면 소스 코드를 제공해준다.  Github App으로 등록되어 있는 Utterances 설치를 진행한다.  댓글이 저장될 Github Repository를 준비하고 다음을 확인한다.          Repository는 public이어야한다. (블로그 소스가 저장된 repository가 private일 경우, repository를 새로 하나 만든다.)      테마를 fork해서 만든 블로그라면, Github Issues가 활성화되어 있는지 확인한다. (Github Repository &gt; Settings &gt; Options &gt; Features &gt; ✅ Issues)        Issue Mapping 방식을 선택한다.          나는 변경 가능성이 제일 적을 것 같은 pathname을 선택했다.              Issue title contains page pathname: 블로그 포스트의 URL 컴포넌트와 매칭된다.(예: category/title)      Issue title contains page URL: 블로그 포스트 URL 전체에 매칭된다.(예: https://username.github.io/category/title)      Issue title contains page title: 블로그 포스트 제목에 매칭된다.      Issue title contains page og:title: 페이지의 오픈 그래프 타이틀 메타데이터에 매칭된다.      Specific issue number: 특정 이슈 번호에 매칭된다. 이슈가 자동으로 생성되지 않는다.      Issue title contains specific term: 특정 키워드에 매칭된다. 이슈 제목은 설정한 키워드로 생성된다.        (선택사항) Label을 설정한다.          Utterances bot🤖이 이슈를 새로 생성할 때 라벨을 붙여주도록 설정할 수 있는데, 이미 존재하는 라벨만 설정이 가능하므로, 아직 라벨을 안 만들었다면 Github Issue에서 먼저 만들어준다.        테마를 선택한다.  생성된 script 코드를 복사한다.[3] 🔮 Utterances 적용[2]에서 복사한 script 코드를 적용하는 방식은 블로그 테마에 따라 다양하다. 이론적으로는 포스트의 레이아웃이 되는 html 파일의 &lt;head&gt;...&lt;/head&gt; 태그 사이에 넣어주면 된다. 하지만 지킬 테마 자체에서 Utterances를 사용할 수 있도록 제작된 테마같은 경우, _config.yml에서 설정할 수 있다. 내가 사용중인 Minimal Mistakes 테마 또한 _config.yml에서 설정이 가능하다.🔽 _config.ymlcomments:  provider               : utterances  utterances:    theme                : \"github-dark-orange\"    issue_term           : \"pathname\"    label                : \"comment\"참고  Utterances Docs"
  },
  
  {
    "title": "[Jekyll Blog] 블로그 시작하기",
    "url": "/posts/build-a-blog/",
    "categories": "Jekyll-Blog",
    "tags": "🧪Jekyll, 💜Blog, Github-Pages",
    "date": "2022-01-02 00:00:00 +0100",
    





    
    "snippet": "  💎Jekyll + Github Pages로 개발 블로그 만들기 / Minimal-Mistakes 테마 커스터마이징하기💎[1] Ruby 설치하기  윈도우 환경을 기준으로 작성하였다. 다른 운영체제에서의 설치 방법은 Jekyll Installation에서 자세히 확인할 수 있다.Jekyll를 사용하려면 아래의 세 가지가 먼저 필요하다.  Ruby (2...",
    "content": "  💎Jekyll + Github Pages로 개발 블로그 만들기 / Minimal-Mistakes 테마 커스터마이징하기💎[1] Ruby 설치하기  윈도우 환경을 기준으로 작성하였다. 다른 운영체제에서의 설치 방법은 Jekyll Installation에서 자세히 확인할 수 있다.Jekyll를 사용하려면 아래의 세 가지가 먼저 필요하다.  Ruby (2.5.0 버전 이상)  RubyGems      GCC와 Make    Ruby Installer에서 2.5.0 버전 이상의 Ruby+Devkit을 다운받는다. (Ruby+Devkit으로 설치하면 위에 언급한 세 가지를 한 큐에 다운받을 수 있다.)  Ruby 설치가 완료되면 자동으로 터미널이 열리면서 MSYS2 설치 옵션을 묻는데, 엔터키를 눌러 기본값으로 진행한다.          터미널을 그냥 종료해버린 경우 터미널에 ridk install 명령어를 입력하여 설치를 진행할 수 있다.        터미널에 명령어를 입력하여 각각이 잘 설치되었는지 확인한다.          Ruby: ruby -v      RubyGems: gem -v      GCC와 Make: gcc -v, g++ -v, make -v      [2] Jekyll과 Bundler 설치하기gem install jekyll bundler터미널에 jekyll -v, bundler -v를 각각 입력하여 설치가 잘 되었는지 확인한다.[3] Sample Blog로 테스트하기  Jekyll계의 Hello, World!라 해두겠다. 테스트용으로 블로그를 생성하고 로컬에서 실행시켜 개발환경이 잘 구축되었는지  확인한다.jekyll new helloBlog        # 사이트 생성cd helloBlog                # 사이트 내로 이동bundle exec jekyll serve    # 사이트 빌드웹 브라우저에서 localhost:4000으로 접속한다.🛑 Trouble Shooting 🛑  3.0.0 버전 이상의 Ruby를 설치했다면 빌드 과정에서 webrick 관련 에러가 발생할 수 있다. 터미널에 bundle add webrick를 입력해 의존성을 추가해주면 된다.[5] Jekyll Theme로 시작하기  지킬 테마를 입혀 기본 프로젝트 골격을 갖추고 로컬에서 실행해본다.  자신의 로컬에서 원하는 위치에 원하는 이름으로 블로그 폴더를 만든다.  jekyllthemes.org에서 마음에 드는 지킬테마를 고른다.  다운로드를 누르면 깃헙 레포지토리로 연결되는데, 해당 테마 소스코드를 다운받고 압축을 풀어 블로그 폴더에 넣는다.  블로그 폴더로 이동해서 주입된 gem을 프로젝트에 설치한다.    bundle install        사이트를 빌드한다.    bundle exec jekyll serve        웹 브라우저에서 localhost:4000으로 접속한다.🛑 Trouble Shooting 🛑  빌드 중에 kramdown-parser-gfm 관련 에러가 발생한다면, Gemfile에 gem kramdown-parser-gfm를 추가하고 bundle install 후 다시 빌드해본다.   *참고: kramdown-parser-gfm는 gfm(Github Favored Markdown)의 마크다운 파일을 HTML로 변환해주는 역할을 한다.minimal-mistakes로 시작하기  나는 이용자도 많고 문서화가 잘 되어 있는 minimal-mistakes 테마로 시작하였다. 군더더기 없는 문서이지만 시작하는 단계에서 💡소소한 팁…(?)💡을 언급하고자 한다.minimal-mistakes 시작가이드를 보면 소스코드를 다운받고 압축을 푼 후, 다음 항목들을 삭제하라고 한다.  .editorconfig  .gitattributes  .github  /docs  /test  CHANGELOG.md  minimal-mistakes-jekyll.gemspec  README.md  screenshot-layouts.png  screenshot.png하지만 /docs/_posts에는 샘플 포스트들이 있어서 글을 작성할 때 형식을 참고하기 좋다. 프로젝트 폴더 바로 밑(루트)에 _posts 폴더를 만들고 그 밑에 samples 폴더를 만들어 샘플 포스트들을 옮겨두었다. 그리고 .gitignore에 _posts/samples를 추가하여 블로그에는 보여지지 않도록 한다.그렇게 설정하면 대략적인 전체 프로젝트 구조는 다음과 같다.📁blog|---📁_includes|---📁_layouts|---📁_sass|---📁_assets|---📁_posts    |---📁samples        |---📄2009-05-15-edge-case-nested-and-mixed-lists.md        |---📄2006-06-01-edge-case-many-tags.md        |---📄2009-07-02-edge-case-many-categories.md        ...|---⚙_config.yml|---🔸.gitignore|---🔺Gemfile|---📄index.html|---📄index.markdown[6] Github Pages로 호스팅하기  로컬에서 작업한 블로그를 이제 Github Pages를 이용하여 호스팅해본다.  Github에서 &lt;username&gt;.github.io 이름으로 Repository를 만든다.  로컬에서 작업한 디렉토리와 방금 만든 레포지토리를 연결한다.      git init  git remote add upstream https://github.com/&lt;username&gt;/&lt;username&gt;.github.io        Gemfile에 gem \"github-pages\"를 추가한다.  _config.yml를 수정한다.    url                      : \"https://&lt;username&gt;.github.io\"baseurl                  : \"\"repository               : \"&lt;username&gt;/&lt;username&gt;.github.io\"        Github에 push한다.    git add .git commit -m \"complete initial setting\"git push origin master        웹 브라우저에서 https://&lt;username&gt;.github.io로 접속한다.[7] 관련 개념 정리Jekyll  Jekyll은 Ruby로 작성된 정적 사이트 생성기이다.Gem  Gem은 Ruby 생태계에서 하나의 기능을 담당하는 모듈을 의미한다.  Jekyll도 Gem이고, Jekyll Plugin으로 사용되는 라이브러리도 모두 Gem이다.Gemfile  Gemfile은 Gem들을 나열한 파일이다.Bundle  Bundler 역시 하나의 Gem인데, Gemfile에 나열되어 있는 모든 Gem들을 설치하는 역할을 한다.Jekyll Cheat SheetGemfile에 새로운 Gem이 추가되었을 때bundle installGemfile에 기존에 있던 Gem의 버전을 변경할 때bundle update로컬에서 사이트 빌드하기bundle exec jekyll serve참고  Minimal Mistakes Jekyll Theme Docs  Jekyll Docs"
  }
  
]

